{"version":3,"sources":["webpack://jsXtract/webpack/universalModuleDefinition","webpack://jsXtract/webpack/bootstrap","webpack://jsXtract/./modules/freeFFT.js","webpack://jsXtract/./modules/functions/xtract_amdf.js","webpack://jsXtract/./modules/functions/xtract_apply_window.js","webpack://jsXtract/./modules/functions/xtract_array_bound.js","webpack://jsXtract/./modules/functions/xtract_array_copy.js","webpack://jsXtract/./modules/functions/xtract_array_deinterlace.js","webpack://jsXtract/./modules/functions/xtract_array_interlace.js","webpack://jsXtract/./modules/functions/xtract_array_max.js","webpack://jsXtract/./modules/functions/xtract_array_min.js","webpack://jsXtract/./modules/functions/xtract_array_normalise.js","webpack://jsXtract/./modules/functions/xtract_array_scale.js","webpack://jsXtract/./modules/functions/xtract_array_sum.js","webpack://jsXtract/./modules/functions/xtract_array_to_JSON.js","webpack://jsXtract/./modules/functions/xtract_asdf.js","webpack://jsXtract/./modules/functions/xtract_assert_array.js","webpack://jsXtract/./modules/functions/xtract_assert_positive_integer.js","webpack://jsXtract/./modules/functions/xtract_autocorrelation.js","webpack://jsXtract/./modules/functions/xtract_average_deviation.js","webpack://jsXtract/./modules/functions/xtract_bark_coefficients.js","webpack://jsXtract/./modules/functions/xtract_chroma.js","webpack://jsXtract/./modules/functions/xtract_complex_spectrum.js","webpack://jsXtract/./modules/functions/xtract_create_window.js","webpack://jsXtract/./modules/functions/xtract_crest.js","webpack://jsXtract/./modules/functions/xtract_dct.js","webpack://jsXtract/./modules/functions/xtract_dct_2.js","webpack://jsXtract/./modules/functions/xtract_energy.js","webpack://jsXtract/./modules/functions/xtract_f0.js","webpack://jsXtract/./modules/functions/xtract_failsafe_f0.js","webpack://jsXtract/./modules/functions/xtract_flatness.js","webpack://jsXtract/./modules/functions/xtract_flatness_db.js","webpack://jsXtract/./modules/functions/xtract_frame_from_array.js","webpack://jsXtract/./modules/functions/xtract_get_data_frames.js","webpack://jsXtract/./modules/functions/xtract_get_number_of_frames.js","webpack://jsXtract/./modules/functions/xtract_harmonic_spectrum.js","webpack://jsXtract/./modules/functions/xtract_highest_value.js","webpack://jsXtract/./modules/functions/xtract_hps.js","webpack://jsXtract/./modules/functions/xtract_init_bark.js","webpack://jsXtract/./modules/functions/xtract_init_chroma.js","webpack://jsXtract/./modules/functions/xtract_init_dct.js","webpack://jsXtract/./modules/functions/xtract_init_dft.js","webpack://jsXtract/./modules/functions/xtract_init_mfcc.js","webpack://jsXtract/./modules/functions/xtract_init_pcp.js","webpack://jsXtract/./modules/functions/xtract_init_wavelet.js","webpack://jsXtract/./modules/functions/xtract_irregularity_j.js","webpack://jsXtract/./modules/functions/xtract_irregularity_k.js","webpack://jsXtract/./modules/functions/xtract_is_denormal.js","webpack://jsXtract/./modules/functions/xtract_kurtosis.js","webpack://jsXtract/./modules/functions/xtract_loudness.js","webpack://jsXtract/./modules/functions/xtract_lowest_value.js","webpack://jsXtract/./modules/functions/xtract_lowhigh.js","webpack://jsXtract/./modules/functions/xtract_lpc.js","webpack://jsXtract/./modules/functions/xtract_lpcc.js","webpack://jsXtract/./modules/functions/xtract_mean.js","webpack://jsXtract/./modules/functions/xtract_mfcc.js","webpack://jsXtract/./modules/functions/xtract_midicent.js","webpack://jsXtract/./modules/functions/xtract_noisiness.js","webpack://jsXtract/./modules/functions/xtract_nonzero_count.js","webpack://jsXtract/./modules/functions/xtract_odd_even_ratio.js","webpack://jsXtract/./modules/functions/xtract_onset.js","webpack://jsXtract/./modules/functions/xtract_pcp.js","webpack://jsXtract/./modules/functions/xtract_peak_spectrum.js","webpack://jsXtract/./modules/functions/xtract_power.js","webpack://jsXtract/./modules/functions/xtract_process_frame_data.js","webpack://jsXtract/./modules/functions/xtract_resample.js","webpack://jsXtract/./modules/functions/xtract_rms_amplitude.js","webpack://jsXtract/./modules/functions/xtract_rolloff.js","webpack://jsXtract/./modules/functions/xtract_sharpness.js","webpack://jsXtract/./modules/functions/xtract_skewness.js","webpack://jsXtract/./modules/functions/xtract_skewness_kurtosis.js","webpack://jsXtract/./modules/functions/xtract_smoothness.js","webpack://jsXtract/./modules/functions/xtract_spectral_centroid.js","webpack://jsXtract/./modules/functions/xtract_spectral_fundamental.js","webpack://jsXtract/./modules/functions/xtract_spectral_inharmonicity.js","webpack://jsXtract/./modules/functions/xtract_spectral_kurtosis.js","webpack://jsXtract/./modules/functions/xtract_spectral_mean.js","webpack://jsXtract/./modules/functions/xtract_spectral_skewness.js","webpack://jsXtract/./modules/functions/xtract_spectral_slope.js","webpack://jsXtract/./modules/functions/xtract_spectral_spread.js","webpack://jsXtract/./modules/functions/xtract_spectral_standard_deviation.js","webpack://jsXtract/./modules/functions/xtract_spectral_variance.js","webpack://jsXtract/./modules/functions/xtract_spectrum.js","webpack://jsXtract/./modules/functions/xtract_standard_deviation.js","webpack://jsXtract/./modules/functions/xtract_sum.js","webpack://jsXtract/./modules/functions/xtract_temporal_centroid.js","webpack://jsXtract/./modules/functions/xtract_tonality.js","webpack://jsXtract/./modules/functions/xtract_tristimulus.js","webpack://jsXtract/./modules/functions/xtract_variance.js","webpack://jsXtract/./modules/functions/xtract_wavelet_f0.js","webpack://jsXtract/./modules/functions/xtract_yin.js","webpack://jsXtract/./modules/functions/xtract_zcr.js","webpack://jsXtract/./modules/index.js","webpack://jsXtract/./modules/objects/CommonMemory.js","webpack://jsXtract/./modules/objects/DataPrototype.js","webpack://jsXtract/./modules/objects/HarmonicSpectrumData.js","webpack://jsXtract/./modules/objects/PeakSpectrumData.js","webpack://jsXtract/./modules/objects/SpectrumData.js","webpack://jsXtract/./modules/objects/TimeData.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACO;AACP;AACA;;;AAGA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,WAAW;AACjC;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,gCAAgC;AAChC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;;AAGA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,OAAO;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;AC9OA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB,QAAQ,gFAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;AACA;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,cAAc,0EAAgB;AAC9B;AACA;AACA,cAAc,0EAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AACO;AACP;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACsB;;AAEzE;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA,SAAS,sGAA8B;AACvC;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACF;AACJ;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA,WAAW,8EAAkB,aAAa,0EAAgB;AAC1D;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACJ;AAC/C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4EAAiB;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AACO;AACP;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AACO;AACP;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAC0D;AAChB;AACnC;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACrB;;AAE9B;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,IAAI,0DAAS;AACb,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AACgF;;AAEhF;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEO;AACP,SAAS,sGAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;AACV;;AAEnC;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,cAAc,0EAAgB;AAC9B;AACA;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,uBAAuB,OAAO;AAC9B;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACR;AACE;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA,cAAc,wEAAe;AAC7B;AACA;AACA,gBAAgB,0EAAgB;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACE;;AAErD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,kBAAkB,kFAAoB;AACtC;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACJ;AACF;AACI;;AAExD;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEO;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA,kBAAkB,4EAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,0EAAgB;AAChC;AACA;;AAEA,cAAc,8EAAkB;;AAEhC;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AACsC;;AAE/B;AACP,WAAW,4DAAS;AACpB;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACR;;AAE3C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,mBAAmB,wEAAe;AAClC;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AACgF;AACtB;AACgB;;AAEnE;AACP;AACA;AACA;AACA,SAAS,sGAA8B;AACvC;AACA;AACA,SAAS,sGAA8B;AACvC;AACA;AACA,SAAS,gFAAmB;AAC5B;AACA;AACA,SAAS,gFAAmB;AAC5B;AACA;AACA,SAAS,sGAA8B;AACvC;AACA;AACA,YAAY,gGAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACsB;;AAEzE;AACP;AACA;AACA;AACA;AACA,aAAa,gFAAmB;AAChC;AACA;AACA,aAAa,sGAA8B;AAC3C;AACA;AACA,aAAa,sGAA8B;AAC3C;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,2BAA2B,4CAA4C;AACvE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACV;;AAEzC;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA,WAAW,sEAAc;AACzB;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAC0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEO;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AACoD;AAC7C;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,eAAe;AACf,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gDAAgD;AAChD,eAAe,YAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAgB;AAC3D,eAAe,WAAW;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClGA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AACoE;;AAE7D;AACP,WAAW,0FAAwB;AACnC;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACV;;AAEzC;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA,WAAW,sEAAc;AACzB;;;;;;;;;;;;;ACXA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,iBAAiB;AAC5C;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;AAC7C;AACP,SAAS,gFAAmB;AAC5B;AACA,WAAW,0EAAgB;AAC3B;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAC0D;AAClB;AACjC;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,KAAK;AACL,WAAW,8DAAU;AACrB;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACqC;AAC2B;AACN;AACM;;AAEhE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,eAAe;AAClC;AACA;AACA;AACA,QAAQ,0DAAS;AACjB,eAAe,sFAAsB;AACrC;AACA;AACA;;AAEO;;AAEP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,sFAAsB;AACvC;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACR;AAC3C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAe;AAC3B;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0EAAgB;AAC1B;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AACO;AACP;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACgE;AACd;AAC3C;AACP,iBAAiB,sFAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA,4BAA4B,wEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACuD;AACS;AACN;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA,IAAI,iEAAgB;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,0DAAS;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa,sFAAsB;AACnC,aAAa,sFAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAS;AACjB,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,QAAQ,0DAAS;AACjB;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5KA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY,0EAAgB;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AACoE;AAC7D;AACP,WAAW,0FAAwB;AACnC;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AAChB;AAC4B;AACpB;;AAE3C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,eAAe,gEAAW;AAC1B;AACA;AACA,6BAA6B,4FAAyB,QAAQ,wEAAe;AAC7E;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;AAC7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,cAAc,0EAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACX;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,SAAS,gFAAmB;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA,IAAI,oEAAgB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACU;AACoB;AACpB;AAChB;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,4BAA4B,0FAAwB;AACpD;AACA;AACA,sCAAsC,8GAAkC,WAAW,0FAAwB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0EAAgB;AAC9B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA,cAAc,0EAAgB;AAC9B;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACU;AACoB;AACpB;AAChB;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,4BAA4B,0FAAwB;AACpD;AACA;AACA,sCAAsC,8GAAkC,WAAW,0FAAwB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0EAAgB;AAC9B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAgB;AACxB,QAAQ,0EAAgB;AACxB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AACoE;AAC7D;AACP,WAAW,0FAAwB;AACnC;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACU;AAC7D;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,4BAA4B,0FAAwB;AACpD;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACU;AAChB;AAC7C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,4BAA4B,0FAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0EAAgB;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACM;AAC3B;;AAE9B;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,0DAAS;AACb,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,eAAe,sFAAsB;AACrC;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACR;AAC3C;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,mBAAmB,wEAAe;AAClC;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;;AAE7C;AACP,SAAS,gFAAmB;AAC5B;AACA,WAAW,0EAAgB;AAC3B;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AACoD;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0EAAgB;AAC9B;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACF;;AAEjD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,sBAAsB,8EAAkB;AACxC;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP;AACA,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAC0D;AAChB;;AAEnC;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,eAAe,gEAAW;AAC1B;AACA,SAAS,gFAAmB;AAC5B;AACA;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;AACV;;AAEnC,iEAAiE;AACxE,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;AACA,QAAQ,0EAAgB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC,oCAAoC;AACpC;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,uBAAuB,cAAc;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA,SAAS;AACT;AACA;;AAEA,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,gEAAW;AAC1B;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtXA;AAAA;AAAA;AAAA;AAC0D;;AAEnD;AACP;AACA,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAC0D;AACnD;AACP,SAAS,gFAAmB;AAC5B;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEwC;AAGC;AAGW;AAGd;AAGC;AAGD;AAGA;AAGE;AAGI;AAGJ;AAGI;AAGE;AAGG;AAGL;AAGG;AAGL;AAGG;AAGZ;AAGa;AAGT;AAGU;AAGD;AAGA;AAGT;AAGA;AAGS;AAGJ;AAGI;AAGF;AAGY;AAGV;AAGA;AAGH;AAGA;AAMH;AAGD;AAGP;AAGI;AAGC;AAGA;AAGG;AAGH;AAGH;AAGI;AAGI;AAGS;AAGjB;AAGS;AAGL;AAGK;AAGP;AAGK;AAGC;AAGV;AAGU;AAGV;AAGD;AAGS;AAGD;AAGF;AAGY;AAGd;AAGE;AAGQ;AAGZ;AAGD;AAGE;AAGU;AAGX;AAGA;AAGa;AAGJ;AAGI;AAGd;AAGC;AAGD;AAGA;AAGE;AAGG;AAGA;AAGA;AAGC;AAGG;AAGJ;AAGC;AAGE;AAGC;AAGC;AAGP;;AAIK;AAGJ;AAGJ;AAGJ;;;AAG5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAQ;AACxC,oCAAoC,mEAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gHAA8B;AAC/C;AACA;AACA,iBAAiB,gHAA8B;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA,2BAA2B,OAAO;AAClC,gCAAgC,2DAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,2GAA2B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gHAA8B;AAC/C;AACA;AACA,iBAAiB,gHAA8B;AAC/C;AACA;AACA,iBAAiB,gHAA8B;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAoGE;;;;;;;;;;;;;ACjhBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAE6D;AACE;AACA;AACI;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,YAAY,SAAI;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,kFAAe;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,SAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oFAAgB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,SAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oFAAgB;AACzC;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,SAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wFAAkB;AAC3C;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;ACtHA;AAAA;AAAA;AAAA;AAAA;AACuE;AACwD;;AAE/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB,4CAA4C,4FAAoB;AAChE,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,2EAAqB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAsB;AACrC;;AAEA;AACA;AACA;AACA;AACA,eAAe,4EAAsB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8EAAwB;AACvC;AACA;;;;;;;;;;;;;AC/KA;AAAA;AAAA;AAAA;AAAA;AAAA;AACoD;AACqB;AACV;;AAExD,mCAAmC,kEAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA,yCAAyC,8FAAqB;AAC9D;AACA;AACA;;AAEA;AACA,mCAAmC,kEAAgB;AACnD;AACA,SAAS;AACT,oCAAoC,oFAAgB;AACpD;AACA;AACA;AACA;;AAEA,0CAA0C,kEAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4C;AACgB;AAC6B;AACV;;;AAGxE,+BAA+B,0DAAY;AAClD;AACA;AACA,iDAAiD,8GAA6B;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0EAAoB;AACpE,qBAAqB,oGAAwB;AAC7C;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,0DAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;;;;;;;;;;;;AChDD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACM;AACW;AACA;AACA;AACA;AACgB;AACR;AACQ;AACJ;AACwB;AACpB;AACA;AACN;AACA;AACwC;AAChD;AACN;AACE;AACE;AACF;AACM;AACN;AACN;AACkB;AACY;AACd;AACpB;AACE;AACE;AACwB;AACtB;AACc;;AAEhE,2BAA2B,4DAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oFAAgB;AAC7C;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,oFAAgB;AAClD;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,oFAAgB;AAClD;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oFAAgB;AAC9C;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,oGAAwB;AACpE;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,4FAAoB;AAC5D;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,oGAAwB;AACpE;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,gGAAsB;AAChE;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,yHAAkC;AACxF;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,qGAAwB;AACpE;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,qGAAwB;AACpE;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,+FAAqB;AAC9D;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,+FAAqB;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2FAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2FAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2FAAoB;AAC5D;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,uFAAiB;AACtD;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,iFAAc;AAChD;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,mFAAe;AAClD;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,qFAAgB;AACpD;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,mFAAe;AAClD;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,yFAAkB;AACxD;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,mFAAe;AAClD;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,6EAAY;AAC5D;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,+FAAqB;AAC9D;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,2GAA2B;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,6FAAoB;AAC5D;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,2EAAW;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6EAAY;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qGAAwB;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+EAAa;AAC9C;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,kEAAgB;AAC5D,qBAAqB,6FAAoB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;;;;;;;;;;;;AC3nBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACF;AACyB;AACN;AACA;AACA;AACV;AAC0B;AAClB;AACoB;AACF;AAClB;AACA;AACV;AACI;AACgB;AACF;AACE;AACN;AACR;AACI;AACN;AACoB;AACtB;AACA;AACF;AACI;AACM;;AAEtD,uBAAuB,4DAAa;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,wBAAwB,0FAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,oFAAgB;AAClD;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,oFAAgB;AAClD;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oFAAgB;AAC9C;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,0EAAW;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,oGAAwB;AACpE;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,kFAAe;AAClD;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,sGAAyB;AACtE;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,qGAAwB;AACpE;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,mFAAe;AAClD;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,mFAAe;AAClD;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,6EAAY;AACnD;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,6FAAoB;AAC5D;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,2FAAmB;AAC1D;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,6FAAoB;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uFAAiB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,+EAAa;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,mFAAe;AACvC,uCAAuC,0DAAY;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6EAAY;AAC1C;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,iGAAsB;AAChE;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,2EAAW;AAC1C;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,2EAAW;AAC1C;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,6EAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mFAAe;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK","file":"jsXtract.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jsXtract\"] = factory();\n\telse\n\t\troot[\"jsXtract\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./modules/index.js\");\n","/*\n * Free FFT and convolution (JavaScript)\n *\n * Copyright (c) 2014 Project Nayuki\n * https://www.nayuki.io/page/free-small-fft-in-multiple-languages\n *\n * (MIT License)\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function.\n */\nexport function transform(real, imag) {\n    if (real.length !== imag.length)\n        throw \"Mismatched lengths\";\n\n    var n = real.length;\n    if (n === 0)\n        return;\n    else if ((n & (n - 1)) === 0) // Is power of 2\n        transformRadix2(real, imag);\n    else // More complicated algorithm for arbitrary sizes\n        transformBluestein(real, imag);\n}\n\n\n/*\n * Computes the inverse discrete Fourier transform (IDFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function. This transform does not perform scaling, so the inverse is not a true inverse.\n */\nexport function inverseTransform(real, imag) {\n    transform(imag, real);\n}\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector's length must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.\n */\n\nexport function transformRadix2(real, imag) {\n    // Initialization\n    if (real.length !== imag.length)\n        throw \"Mismatched lengths\";\n    var n = real.length;\n    if (n === 1) // Trivial transform\n        return;\n    var levels = calculateNumberLevels(n);\n    if (levels === -1)\n        throw \"Length is not a power of 2\";\n    var cosTable = new Float64Array(n / 2);\n    var sinTable = new Float64Array(n / 2);\n    calculateCosSineTables(cosTable, sinTable);\n\n    // Bit-reversed addressing permutation\n    bitReverseMap(real, imag);\n\n    // Cooley-Tukey decimation-in-time radix-2 FFT\n    for (var size = 2; size <= n; size *= 2) {\n        cooleyTukey(real, imag, sinTable, cosTable, size);\n    }\n\n    // Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.\n    function reverseBits(x, bits) {\n        var y = 0;\n        for (var i = 0; i < bits; i++) {\n            y = (y << 1) | (x & 1);\n            x >>>= 1;\n        }\n        return y;\n    }\n\n    function cooleyTukey(real, imag, sinTable, cosTable, size) {\n        var i, j, k;\n        var n = real.length;\n        var halfsize = size / 2;\n        var tablestep = n / size;\n        for (i = 0; i < n; i += size) {\n            for (j = i, k = 0; j < i + halfsize; j++, k += tablestep) {\n                var tpre = real[j + halfsize] * cosTable[k] + imag[j + halfsize] * sinTable[k];\n                var tpim = -real[j + halfsize] * sinTable[k] + imag[j + halfsize] * cosTable[k];\n                real[j + halfsize] = real[j] - tpre;\n                imag[j + halfsize] = imag[j] - tpim;\n                real[j] += tpre;\n                imag[j] += tpim;\n            }\n        }\n    }\n\n    function calculateNumberLevels(N) {\n        var i;\n        for (i = 0; i < 32; i++) {\n            if (1 << i === N) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    function bitReverseMap(real, imag) {\n        var i, j, temp;\n        for (i = 0; i < n; i++) {\n            j = reverseBits(i, levels);\n            if (j > i) {\n                temp = real[i];\n                real[i] = real[j];\n                real[j] = temp;\n                temp = imag[i];\n                imag[i] = imag[j];\n                imag[j] = temp;\n            }\n        }\n    }\n\n    function calculateCosSineTables(cosTable, sinTable) {\n        var n = cosTable.length,\n            i;\n        for (i = 0; i < n; i++) {\n            cosTable[i] = Math.cos(Math.PI * i / n);\n            sinTable[i] = Math.sin(Math.PI * i / n);\n        }\n    }\n}\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This requires the convolution function, which in turn requires the radix-2 FFT function.\n * Uses Bluestein's chirp z-transform algorithm.\n */\nexport function transformBluestein(real, imag) {\n    // Find a power-of-2 convolution length m such that m >= n * 2 + 1\n    if (real.length !== imag.length)\n        throw \"Mismatched lengths\";\n    var i, j;\n    var n = real.length;\n    var m = 1;\n    while (m < n * 2 + 1)\n        m *= 2;\n\n    // Trignometric tables\n    var cosTable = new Float64Array(n);\n    var sinTable = new Float64Array(n);\n    (function (cosTable, sinTable) {\n        for (i = 0; i < n; i++) {\n            j = i * i % (n * 2); // This is more accurate than j = i * i\n            cosTable[i] = Math.cos(Math.PI * j / n);\n            sinTable[i] = Math.sin(Math.PI * j / n);\n        }\n    })(cosTable, sinTable);\n\n    // Temporary vectors and preprocessing\n    var areal = new Float64Array(m);\n    var aimag = new Float64Array(m);\n\n    for (i = 0; i < n; i++) {\n        areal[i] = real[i] * cosTable[i] + imag[i] * sinTable[i];\n        aimag[i] = -real[i] * sinTable[i] + imag[i] * cosTable[i];\n    }\n    var breal = new Float64Array(m);\n    var bimag = new Float64Array(m);\n    breal[0] = cosTable[0];\n    bimag[0] = sinTable[0];\n    for (i = 1; i < n; i++) {\n        breal[i] = breal[m - i] = cosTable[i];\n        bimag[i] = bimag[m - i] = sinTable[i];\n    }\n\n    // Convolution\n    var creal = new Float64Array(m);\n    var cimag = new Float64Array(m);\n    convolveComplex(areal, aimag, breal, bimag, creal, cimag);\n\n    // Postprocessing\n    for (i = 0; i < n; i++) {\n        real[i] = creal[i] * cosTable[i] + cimag[i] * sinTable[i];\n        imag[i] = -creal[i] * sinTable[i] + cimag[i] * cosTable[i];\n    }\n}\n\n\n/*\n * Computes the circular convolution of the given real vectors. Each vector's length must be the same.\n */\nfunction convolveReal(x, y, out) {\n    if (x.length !== y.length || x.length !== out.length)\n        throw \"Mismatched lengths\";\n    var zeros = new Array(x.length);\n    for (var i = 0; i < zeros.length; i++)\n        zeros[i] = 0;\n    convolveComplex(x, zeros, y, zeros.slice(), out, zeros.slice());\n}\n\n\n/*\n * Computes the circular convolution of the given complex vectors. Each vector's length must be the same.\n */\nexport function convolveComplex(xreal, ximag, yreal, yimag, outreal, outimag) {\n    (function () {\n        if (xreal.length !== ximag.length || xreal.length !== yreal.length || yreal.length !== yimag.length || xreal.length !== outreal.length || outreal.length !== outimag.length)\n            throw \"Mismatched lengths\";\n    })();\n    var i;\n    var n = xreal.length;\n    xreal = xreal.slice();\n    ximag = ximag.slice();\n    yreal = yreal.slice();\n    yimag = yimag.slice();\n\n    transform(xreal, ximag);\n    transform(yreal, yimag);\n    for (i = 0; i < n; i++) {\n        var temp = xreal[i] * yreal[i] - ximag[i] * yimag[i];\n        ximag[i] = ximag[i] * yreal[i] + xreal[i] * yimag[i];\n        xreal[i] = temp;\n    }\n    inverseTransform(xreal, ximag);\n    for (i = 0; i < n; i++) { // Scaling (because this FFT implementation omits it)\n        outreal[i] = xreal[i] / n;\n        outimag[i] = ximag[i] / n;\n    }\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_amdf(array) {\n    if (!xtract_assert_array(array))\n        return 0;\n    var n = array.length;\n    var result = new Float64Array(n);\n    while (n--) {\n        var md = 0.0;\n        for (var i = 0; i < array.length - n; i++) {\n            md += Math.abs(array[i] - array[i + n]);\n        }\n        result[n] = md / array.length;\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_apply_window(X, W) {\n    if (!xtract_assert_array(X) || !xtract_assert_array(W)) {\n        throw (\"Both X and W must be defined\");\n    }\n    if (X.length !== W.length) {\n        throw (\"Both X and W must be the same lengths\");\n    }\n    var N = X.length;\n    var Y = new Float64Array(N);\n    var n;\n    for (n = 0; n < N; n++) {\n        Y[n] = X[n] * W[n];\n    }\n    return Y;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_min} from \"./xtract_array_min\";\nimport {xtract_array_max} from \"./xtract_array_max\";\n\nexport function xtract_array_bound(data, min, max) {\n    if (!xtract_assert_array(data))\n        return 0;\n    if (typeof min !== \"number\") {\n        min = xtract_array_min(data);\n    }\n    if (typeof max !== \"number\") {\n        max = xtract_array_max(data);\n    }\n    if (min >= max) {\n        throw (\"Invalid boundaries! Minimum cannot be greater than maximum\");\n    }\n    var result = new data.constructor(data.length);\n    for (var n = 0; n < data.length; n++) {\n        result[n] = Math.min(Math.max(data[n], min), max);\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_array_copy(src) {\n    var N = src.length,\n        dst = new src.constructor(N);\n    for (var n = 0; n < N; n++)\n        dst[n] = src[n];\n    return dst;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_assert_positive_integer} from \"./xtract_assert_positive_integer\";\n\nexport function xtract_array_deinterlace(data, num_arrays) {\n    if (!xtract_assert_array(data)) {\n        return [];\n    }\n    var result, N;\n    if (!xtract_assert_positive_integer(num_arrays)) {\n        throw (\"num_arrays must be a positive integer\");\n    }\n    result = [];\n    N = data.length / num_arrays;\n    for (var n = 0; n < num_arrays; n++) {\n        result[n] = new data.constructor(N);\n    }\n    for (var k = 0; k < N; k++) {\n        for (var j = 0; j < num_arrays; j++) {\n            result[j][k] = data[k * num_arrays + j];\n        }\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_array_interlace(data) {\n    if (!xtract_assert_array(data)) {\n        return [];\n    }\n    var num_arrays = data.length,\n        length = data[0].length;\n    if (data.every(function (a) {\n            return a.length === length;\n        }) === false) {\n        throw (\"All argument lengths must be the same\");\n    }\n    var result = new data[0].constructor(num_arrays * length);\n    for (var k = 0; k < length; k++) {\n        for (var j = 0; j < num_arrays; j++) {\n            result[k * num_arrays + j] = data[j][k];\n        }\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_array_max(data) {\n    if (!xtract_assert_array(data))\n        return -Infinity;\n    if (data.reduce) {\n        return data.reduce(function (a, b) {\n            if (b > a) {\n                return b;\n            }\n            return a;\n        }, data[0]);\n    }\n    var max = data[0],\n        l = data.length;\n    for (var n = 1; n < l; n++) {\n        if (data[n] > max) {\n            max = data[n];\n        }\n    }\n    return max;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_array_min(data) {\n    if (!xtract_assert_array(data))\n        return Infinity;\n    if (data.reduce) {\n        return data.reduce(function (a, b) {\n            if (b < a) {\n                return b;\n            }\n            return a;\n        }, data[0]);\n    }\n    var min = Infinity,\n        l = data.length;\n    for (var n = 0; n < l; n++) {\n        if (data[n] < min) {\n            min = data[n];\n        }\n    }\n    return min;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_scale} from \"./xtract_array_scale\";\nimport {xtract_array_max} from \"./xtract_array_max\";\n\nexport function xtract_array_normalise(data) {\n    if (!xtract_assert_array(data))\n        return 0;\n    return xtract_array_scale(data, 1.0 / xtract_array_max(data));\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_copy} from \"./xtract_array_copy\";\nexport function xtract_array_scale(data, factor) {\n    if (!xtract_assert_array(data))\n        return 0;\n    if (typeof factor !== \"number\") {\n        return 0;\n    }\n    var i = 0,\n        l = data.length,\n        a = xtract_array_copy(data);\n    for (i = 0; i < l; i++) {\n        a[i] *= factor;\n    }\n    return a;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_array_sum(data) {\n    if (!xtract_assert_array(data))\n        return 0;\n    if (data.reduce) {\n        return data.reduce(function (a, b) {\n            return a + b;\n        }, 0);\n    }\n    var sum = 0,\n        l = data.length;\n    for (var n = 0; n < l; n++) {\n        sum += data[n];\n    }\n    return sum;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_array_to_JSON(array) {\n    if (array.join) {\n        return '[' + array.join(', ') + ']';\n    }\n    var json = '[';\n    var n = 0;\n    while (n < this.length) {\n        json = json + this[n];\n        if (this[n + 1] !== undefined) {\n            json = json + ',';\n        }\n        n++;\n    }\n    return json + ']';\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_asdf(array) {\n    if (!xtract_assert_array(array))\n        return 0;\n    var n = array.length;\n    var result = new Float64Array(n);\n    while (n--) {\n        var sd = 0.0;\n        for (var i = 0; i < array.length - n; i++) {\n            sd += Math.pow(array[i] - array[i + n], 2);\n        }\n        result[n] = sd / array.length;\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_assert_array(array) {\n    return (typeof array === \"object\" && array.length !== undefined && array.length > 0);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_assert_positive_integer(number) {\n    return (typeof number === \"number\" && number >= 0 && number === Math.round(number));\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_autocorrelation(array) {\n    if (!xtract_assert_array(array))\n        return 0;\n    var n = array.length;\n    var result = new Float64Array(n);\n    while (n--) {\n        var corr = 0;\n        for (var i = 0; i < array.length - n; i++) {\n            corr += array[i] * array[i + n];\n        }\n        result[n] = corr / array.length;\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_mean} from \"./xtract_mean\";\nexport function xtract_average_deviation(array, mean) {\n    if (!xtract_assert_array(array))\n        return 0;\n    if (typeof mean !== \"number\") {\n        mean = xtract_mean(array);\n    }\n    var result = 0.0;\n    if (array.reduce) {\n        result = array.reduce(function (a, b) {\n            return a + Math.abs(b - mean);\n        }, 0);\n    } else {\n        for (var n = 0; n < array.length; n++) {\n            result += Math.abs(array[n] - mean);\n        }\n    }\n    return result / array.length;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_bark_coefficients(spectrum, bark_limits) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    if (bark_limits === undefined) {\n        throw (\"xtract_bark_coefficients requires compute limits from xtract_init_bark\");\n    }\n    var N = spectrum.length >> 1;\n    var bands = bark_limits.length;\n    var results = new Float64Array(bands);\n    for (var band = 0; band < bands - 1; band++) {\n        results[band] = 0.0;\n        for (var n = bark_limits[band]; n < bark_limits[band + 1]; n++) {\n            results[band] += spectrum[n];\n        }\n    }\n    return results;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_chroma(spectrum, chromaFilters) {\n    if (!xtract_assert_array(spectrum)) {\n        return 0;\n    }\n    if (chromaFilters.wts === undefined) {\n        throw (\"xtract_chroma requires chroma filters from xtract_init_chroma\");\n    }\n    if (chromaFilters.nfft !== spectrum.length / 2) {\n        throw (\"the FFT lengths of the spectrum (\" + spectrum.length / 2 + \") and chroma filterbank (\" + chromaFilters.nfft + \") do not match\");\n    }\n    var result = new Float64Array(chromaFilters.nbins);\n    for (var i = 0; i < chromaFilters.nbins; i++) {\n        var sum = 0;\n        for (var j = 0; j < chromaFilters.nfft; j++) {\n            sum += chromaFilters.wts[i][j] * spectrum[j];\n        }\n        result[i] = sum;\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {transform} from \"../freeFFT\";\n\nexport function xtract_complex_spectrum(array, sample_rate, withDC) {\n    if (!xtract_assert_array(array))\n        return 0;\n    if (typeof sample_rate !== \"number\") {\n        console.error(\"Sample Rate must be defined\");\n        return null;\n    }\n    if (withDC === undefined) {\n        withDC = false;\n    }\n    var N = array.length;\n    var result, align = 0,\n        amps, freqs;\n    if (withDC) {\n        result = new Float64Array(3 * (N / 2 + 1));\n    } else {\n        align = 1;\n        result = new Float64Array(3 * (N / 2));\n    }\n    amps = result.subarray(0, 2 * (result.length / 3));\n    freqs = result.subarray(2 * (result.length / 3));\n    var reals = new Float64Array(N);\n    var imags = new Float64Array(N);\n    for (var i = 0; i < N; i++) {\n        reals[i] = array[i];\n    }\n    transform(reals, imags);\n    for (var k = align; k <= reals.length / 2; k++) {\n        amps[(k - align) * 2] = reals[k];\n        amps[(k - align) * 2 + 1] = imags[k];\n        freqs[k - align] = (2 * k / N) * (sample_rate / 2);\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_positive_integer} from \"./xtract_assert_positive_integer\";\n\nfunction welch(N) {\n    var W = new Float64Array(N);\n    var n;\n    var N12 = (N - 1) / 2;\n    for (n = 0; n < N; n++) {\n        W[n] = 1.0 - Math.pow((n - N12) / N12, 2);\n    }\n    return W;\n}\n\nfunction sine(N) {\n    var w = new Float64Array(N),\n        n;\n    var arga = (Math.PI * n) / (N - 1);\n    for (n = 0; n < N; n++) {\n        w[n] = Math.sin(arga);\n    }\n    return w;\n}\n\nfunction hann(N) {\n    var w = new Float64Array(N),\n        n;\n    for (n = 0; n < N; n++) {\n        w[n] = 0.5 - (1 - Math.cos((Math.PI * 2 * n) / (N - 1)));\n    }\n    return w;\n}\n\nfunction hamming(N) {\n    var w = new Float64Array(N),\n        alpha = 25 / 46,\n        beta = 21 / 46,\n        n;\n    for (n = 0; n < N; n++) {\n        w[n] = alpha - beta * Math.cos((Math.PI * 2 * n) / (N - 1));\n    }\n    return w;\n}\n\nexport function xtract_create_window(N, type) {\n    if (!xtract_assert_positive_integer(N)) {\n        throw (\"N must be a defined, positive integer\");\n    }\n    if (typeof type !== \"string\" || type.length === 0) {\n        throw (\"Type must be defined\");\n    }\n    type = type.toLowerCase();\n    switch (type) {\n        case \"hamming\":\n            return hamming(N);\n        case \"welch\":\n            return welch(N);\n        case \"sine\":\n            return sine(N);\n        case \"hann\":\n            return hann(N);\n        default:\n            throw (\"Window function\\\"\" + type + \"\\\" not defined\");\n    }\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_max} from \"./xtract_array_max\";\nimport {xtract_mean} from \"./xtract_mean\";\n\nexport function xtract_crest(data, max, mean) {\n    if (!xtract_assert_array(data))\n        return 0;\n    if (typeof max !== \"number\") {\n        max = xtract_array_max(data);\n    }\n    if (typeof mean !== \"number\") {\n        mean = xtract_mean(data);\n    }\n    return max / mean;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_dct(array) {\n    if (!xtract_assert_array(array))\n        return 0;\n    var N = array.length;\n    var result = new Float64Array(N);\n    if (array.reduce) {\n        result.forEach(function (e, i, a) {\n            var nN = i / N;\n            a[i] = array.reduce(function (r, d, m) {\n                return r + d * Math.cos(Math.PI * nN * (m + 0.5));\n            });\n        });\n    } else {\n        for (var n = 0; n < N; n++) {\n            var nN = n / N;\n            for (var m = 0; m < N; m++) {\n                result[n] += array[m] * Math.cos(Math.PI * nN * (m + 0.5));\n            }\n        }\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_init_dct} from \"./xtract_init_dct\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\n\nexport function xtract_dct_2(array, dct) {\n    if (!xtract_assert_array(array))\n        return 0;\n    var N = array.length;\n    if (dct === undefined) {\n        dct = xtract_init_dct(N);\n    }\n    var result = new Float64Array(N);\n    result[0] = xtract_array_sum(array);\n    if (result.forEach && array.reduce) {\n        result.forEach(function (e, k, ar) {\n            ar[k] = array.reduce(function (a, b, n) {\n                return a + b * dct.wt[k][n];\n            });\n        });\n    } else {\n        for (var k = 1; k < N; k++) {\n            for (var n = 0; n < N; n++) {\n                result[k] += array[n] * dct.wt[k][n];\n            }\n        }\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_rms_amplitude} from \"./xtract_rms_amplitude\";\n\nexport function xtract_energy(array, sample_rate, window_ms) {\n    if (!xtract_assert_array(array))\n        return 0;\n    if (typeof sample_rate !== \"number\") {\n        console.error(\"xtract_energy requires sample_rate to be defined\");\n        return;\n    }\n    if (typeof window_ms !== \"number\") {\n        window_ms = 100;\n    }\n    if (window_ms <= 0) {\n        window_ms = 100;\n    }\n    var N = array.length;\n    var L = Math.floor(sample_rate * (window_ms / 1000.0));\n    var K = Math.ceil(N / L);\n    var result = new Float64Array(K);\n    for (var k = 0; k < K; k++) {\n        var frame = array.subarray(k * L, k * L + L);\n        var rms = xtract_rms_amplitude(frame);\n        result[k] = rms;\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_copy} from \"./xtract_array_copy\";\nimport {xtract_array_max} from \"./xtract_array_max\";\nimport {xtract_array_bound} from \"./xtract_array_bound\";\n\nfunction calc_err_tau_x(sub_arr, M, tau) {\n    var err_tau = 0.0,\n        n;\n    for (n = 1; n < M; n++) {\n        err_tau += Math.abs(sub_arr[n] - sub_arr[n + tau]);\n    }\n    return err_tau;\n}\n\nexport function xtract_f0(timeArray, sampleRate) {\n    if (!xtract_assert_array(timeArray))\n        return 0;\n    if (typeof sampleRate !== \"number\") {\n        sampleRate = 44100.0;\n    }\n    var sub_arr = xtract_array_copy(timeArray);\n    var N = sub_arr.length;\n    var M = N / 2;\n    var n;\n\n    var threshold_peak = 0.8,\n        threshold_centre = 0.3,\n        array_max = 0;\n\n    array_max = xtract_array_max(sub_arr);\n    threshold_peak *= array_max;\n    threshold_centre *= array_max;\n\n    sub_arr = xtract_array_bound(sub_arr, -threshold_peak, threshold_peak);\n\n    sub_arr.forEach(function (v, i, a) {\n        a[i] = Math.max(0, v - threshold_centre);\n    });\n\n    var err_tau_1 = calc_err_tau_x(sub_arr, M, 1);\n    for (var tau = 2; tau < M; tau++) {\n        var err_tau_x = calc_err_tau_x(sub_arr, M, tau);\n        if (err_tau_x < err_tau_1) {\n            return sampleRate / (tau + (err_tau_x / err_tau_1));\n        }\n    }\n    return -0;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_f0} from \"./xtract_f0\";\n\nexport function xtract_failsafe_f0(timeArray, sampleRate) {\n    return xtract_f0(timeArray, sampleRate);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_flatness(spectrum) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var count = 0,\n        denormal_found = false,\n        num = 1.0,\n        den = 0.0,\n        temp = 0.0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    var amps = spectrum.subarray(0, K);\n    for (var n = 0; n < K; n++) {\n        temp = Math.max(1e-32, amps[n]);\n        num *= temp;\n        den += temp;\n        count++;\n    }\n    if (count === 0) {\n        return 0;\n    }\n    num = Math.pow(num, 1.0 / count);\n    den /= count;\n\n    return num / den;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_flatness} from \"./xtract_flatness\";\n\nexport function xtract_flatness_db(spectrum, flatness) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    if (typeof flatness !== \"number\") {\n        flatness = xtract_flatness(spectrum);\n    }\n    return 10.0 * Math.log10(flatness);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_positive_integer} from \"./xtract_assert_positive_integer\";\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_get_number_of_frames} from \"./xtract_get_number_of_frames\";\n\nexport function xtract_frame_from_array(src, dst, index, frame_size, hop_size) {\n    if (hop_size === undefined) {\n        hop_size = frame_size;\n    }\n    if (!xtract_assert_positive_integer(index)) {\n        throw (\"xtract_get_frame requires the index to be an integer value\");\n    }\n    if (!xtract_assert_positive_integer(frame_size)) {\n        throw (\"xtract_get_frame requires the frame_size to be a positive integer\");\n    }\n    if (!xtract_assert_array(src)) {\n        throw (\"Invalid data parameter. Must be item with iterable list\");\n    }\n    if (!xtract_assert_array(dst)) {\n        throw (\"dst must be an Array-like object equal in length to frame_size\");\n    }\n    if (!xtract_assert_positive_integer(hop_size)) {\n        throw (\"xtract_get_frame requires the hop_size to be a positive integer\");\n    }\n    var K = xtract_get_number_of_frames(src, hop_size);\n    if (index >= K) {\n        throw (\"index number \" + index + \" out of bounds\");\n    }\n    var n = 0;\n    var offset = index * hop_size;\n    while (n < dst.length && n < src.length && n < frame_size) {\n        dst[n] = src[n + offset];\n        n++;\n    }\n    while (n < dst.length) {\n        dst[n] = 0.0;\n    }\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_assert_positive_integer} from \"./xtract_assert_positive_integer\";\n\nexport function xtract_get_data_frames(data, frame_size, hop_size, copy) {\n    if (hop_size === undefined) {\n        hop_size = frame_size;\n    }\n    (function (data, frame_size, hop_size) {\n        if (!xtract_assert_array(data)) {\n            throw (\"Invalid data parameter. Must be item with iterable list\");\n        }\n        if (!xtract_assert_positive_integer(frame_size)) {\n            throw (\"xtract_get_data_frames requires the frame_size to be a positive integer\");\n        }\n        if (!xtract_assert_positive_integer(hop_size)) {\n            throw (\"xtract_get_data_frames requires the hop_size to be a positive integer\");\n        }\n        return true;\n    })(data, frame_size, hop_size);\n\n    var frames = [];\n    var N = data.length;\n    var K = Math.ceil(N / hop_size);\n    var sub_frame;\n    for (var k = 0; k < K; k++) {\n        var offset = k * hop_size;\n        if (copy) {\n            sub_frame = new Float64Array(frame_size);\n            for (var n = 0; n < frame_size && n + offset < data.length; n++) {\n                sub_frame[n] = data[n + offset];\n            }\n        } else {\n            sub_frame = data.subarray(offset, offset + frame_size);\n            if (sub_frame.length < frame_size) {\n                // Must zero-pad up to the length\n                var c_frame = new Float64Array(frame_size);\n                for (var i = 0; i < sub_frame.length; i++) {\n                    c_frame[i] = sub_frame[i];\n                }\n                sub_frame = c_frame;\n            }\n        }\n        frames.push(sub_frame);\n    }\n    return frames;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_get_number_of_frames(data, hop_size) {\n    if (!xtract_assert_array(data)) {\n        throw (\"Invalid data parameter. Must be item with iterable list\");\n    }\n    if (typeof hop_size !== \"number\" && hop_size <= 0) {\n        throw (\"Invalid hop_size. Must be positive integer\");\n    }\n    return Math.floor(data.length / hop_size);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_harmonic_spectrum(peakSpectrum, f0, threshold) {\n    if (!xtract_assert_array(peakSpectrum))\n        return 0;\n    var N = peakSpectrum.length;\n    var K = N >> 1;\n    var result = new Float64Array(N);\n    var ampsIn = peakSpectrum.subarray(0, K);\n    var freqsIn = peakSpectrum.subarray(K);\n    var ampsOut = result.subarray(0, K);\n    var freqsOut = result.subarray(K);\n    var n = K;\n    if (f0 === undefined || threshold === undefined) {\n        throw (\"harmonic_spectrum requires f0 and threshold to be numbers and defined\");\n    }\n    if (threshold > 1) {\n        threshold /= 100.0;\n    }\n    while (n--) {\n        if (freqsIn[n] !== 0.0) {\n            var ratio = freqsIn[n] / f0;\n            var nearest = Math.round(ratio);\n            var distance = Math.abs(nearest - ratio);\n            if (distance > threshold) {\n                ampsOut[n] = 0.0;\n                freqsOut[n] = 0.0;\n            } else {\n                ampsOut[n] = ampsIn[n];\n                freqsOut[n] = freqsIn[n];\n            }\n        } else {\n            result[n] = 0.0;\n            freqsOut[n] = 0.0;\n        }\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_lowhigh} from \"./xtract_lowhigh\";\n\nexport function xtract_highest_value(data, threshold) {\n    if (!xtract_assert_array(data))\n        return 0;\n    if (typeof threshold !== \"number\") {\n        threshold = +Infinity;\n    }\n    return xtract_lowhigh(data, threshold).max;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nfunction get_peak_index(M, amps) {\n    var peak_index = 0,\n        peak = 0,\n        i;\n    var tempProduct = new Float64Array(M);\n    tempProduct.forEach(function (e, i, a) {\n        a[i] = amps[i] * amps[i * 2] * amps[i * 3];\n    });\n    tempProduct.forEach(function (v, i) {\n        if (v > peak) {\n            peak = v;\n            peak_index = i;\n        }\n    });\n    return peak_index;\n}\n\nexport function xtract_hps(spectrum) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var peak_index = 0,\n        position1_lwr = 0,\n        largest1_lwr = 0,\n        ratio1 = 0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    var amps = spectrum.subarray(0, K);\n    var freqs = spectrum.subarray(K);\n    var M = Math.ceil(K / 3.0);\n    var i;\n    if (M <= 1) {\n        throw (\"Input Data is too short for HPS\");\n    }\n\n    peak_index = get_peak_index(M, amps);\n\n    for (i = 0; i < K; i++) {\n        if (amps[i] > largest1_lwr && i !== peak_index) {\n            largest1_lwr = amps[i];\n            position1_lwr = i;\n        }\n    }\n\n    ratio1 = amps[position1_lwr] / amps[peak_index];\n\n    if (position1_lwr > peak_index * 0.4 && position1_lwr < peak_index * 0.6 && ratio1 > 0.1)\n        peak_index = position1_lwr;\n\n    return freqs[peak_index];\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_init_bark(N, sampleRate, bands) {\n    if (typeof bands !== \"number\" || bands < 0 || bands > 26) {\n        bands = 26;\n    }\n    var edges = [0, 100, 200, 300, 400, 510, 630, 770, 920, 1080, 1270, 1480, 1720, 2000, 2320, 2700, 3150, 3700, 4400, 5300, 6400, 7700, 9500, 12000, 15500, 20500, 27000];\n    var band_limits = new Int32Array(bands);\n    while (bands--) {\n        band_limits[bands] = (edges[bands] / sampleRate) * N;\n    }\n    return band_limits;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_array_sum} from \"./xtract_array_sum\";\nexport function xtract_init_chroma(N, sampleRate, nbins, A440, f_ctr, octwidth) {\n    /*run arg checks here... (if(nbins=='undefined')*/\n\n    if (typeof nbins !== \"number\" || nbins <= 1) {\n        nbins = 12;\n    }\n    if (typeof A440 !== \"number\" || A440 <= 27.5) {\n        A440 = 440;\n    }\n    if (typeof f_ctr !== \"number\") {\n        f_ctr = 1000;\n    }\n    if (typeof octwidth !== \"number\") {\n        octwidth = 1;\n    }\n    var A0 = 27.5; // A0 in Hz\n    var N2 = N; // ignore freq values returned by xtract_spectrum - this relies on dc-offset being kept\n    var ctroct = Math.log(f_ctr / A0) / Math.LN2; // f_ctr in octaves\n    var chromaFilters = {\n        wts: [],\n        nfft: N2,\n        nbins: nbins,\n    };\n    var fftfrqbins = new Float64Array(N2);\n    var binwidthbins = new Float64Array(N2);\n    // Convert a frequency in Hz into a real number counting the octaves above A0. So hz2octs(440) = 4.0\n    var hz2octs = function (freq) {\n        return Math.log(freq / (A440 / 16)) / Math.LN2;\n    };\n    var i, j;\n    for (i = 1; i < N2; i++) {\n        fftfrqbins[i] = nbins * hz2octs(i / N * sampleRate);\n    }\n    fftfrqbins[0] = fftfrqbins[1] - 1.5 * nbins; //DC offset bin\n    for (i = 0; i < N2 - 1; i++) {\n        var diffVal = fftfrqbins[i + 1] - fftfrqbins[i];\n        if (diffVal >= 1) {\n            binwidthbins[i] = diffVal;\n        } else {\n            binwidthbins[i] = 1;\n        }\n    }\n    binwidthbins[N2 - 1] = 1;\n    var nbins2 = Math.round(nbins / 2.0);\n    var wts = [];\n    for (i = 0; i < nbins; i++) {\n        wts[i] = [];\n        for (j = 0; j < N2; j++) {\n            var tmpF = fftfrqbins[j] - i;\n            var tmpB = binwidthbins[j];\n            var remF = ((tmpF + nbins2 + 10 * nbins) % nbins) - nbins2;\n            wts[i][j] = Math.exp(-0.5 * Math.pow((2 * remF / tmpB), 2));\n        }\n    }\n\n    function head(a) {\n        return a[0];\n    }\n\n    function tail(a) {\n        return a.slice(1);\n    }\n\n    function transpose(a) {\n        if (a === undefined) {\n            return [];\n        }\n        var x = a.length,\n            y = a[0].length,\n            mtx = [],\n            i, j;\n        for (i = 0; i < y; i++) {\n            mtx[i] = new Float64Array(x);\n        }\n        for (i = 0; i < x; i++) {\n            for (j = 0; j < y; j++) {\n                mtx[j][i] = a[i][j];\n            }\n        }\n        return mtx;\n    }\n    var wtsColumnSums = transpose(wts).map(xtract_array_sum);\n    for (i = 0; i < nbins; i++) {\n        for (j = 0; j < N2; j++) {\n            wts[i][j] *= 1 / wtsColumnSums[j];\n        }\n    }\n    if (octwidth > 0) {\n        for (i = 0; i < nbins; i++) {\n            for (j = 0; j < N2; j++) {\n                wts[i][j] *= Math.exp(-0.5 * (Math.pow(((fftfrqbins[j] / nbins - ctroct) / octwidth), 2)));\n            }\n        }\n    }\n    chromaFilters.wts = wts;\n    return chromaFilters;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_init_dct(N) {\n    var dct = {\n        N: N,\n        wt: []\n    };\n    for (var k = 0; k < N; k++) {\n        dct.wt[k] = new Float64Array(N);\n        for (var n = 0; n < N; n++) {\n            dct.wt[k][n] = Math.cos(Math.PI * k * (n + 0.5) / N);\n        }\n    }\n    return dct;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_init_dft(N) {\n    var dft = {\n        N: N / 2 + 1,\n        real: [],\n        imag: []\n    };\n    var power_const = -2.0 * Math.PI / N;\n    for (var k = 0; k < dft.N; k++) {\n        var power_k = power_const * k;\n        dft.real[k] = new Float64Array(N);\n        dft.imag[k] = new Float64Array(N);\n        for (var n = 0; n < N; n++) {\n            var power = power_k * n;\n            dft.real[k][n] = Math.cos(power);\n            dft.imag[k][n] = Math.sin(power);\n        }\n    }\n    return dft;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\n\nfunction get_fft_peak(N, freq_max, freq_min, freq_bands, nyquist, style) {\n    var norm = 1,\n        M = N / 2,\n        height, norm_fact, n;\n    var mel_freq_max = 1127 * Math.log(1 + freq_max / 700);\n    var mel_freq_min = 1127 * Math.log(1 + freq_min / 700);\n    var freq_bw_mel = (mel_freq_max - mel_freq_min) / freq_bands;\n\n    var mel_peak = new Float64Array(freq_bands + 2);\n    var lin_peak = new Float64Array(freq_bands + 2);\n    var fft_peak = new Float64Array(freq_bands + 2);\n    var height_norm = new Float64Array(freq_bands);\n    mel_peak[0] = mel_freq_min;\n    lin_peak[0] = freq_min;\n    fft_peak[0] = Math.floor(lin_peak[0] / nyquist * M);\n\n    for (n = 1; n < (freq_bands + 2); ++n) {\n        //roll out peak locations - mel, linear and linear on fft window scale\n        mel_peak[n] = mel_peak[n - 1] + freq_bw_mel;\n        lin_peak[n] = 700 * (Math.exp(mel_peak[n] / 1127) - 1);\n        fft_peak[n] = Math.floor(lin_peak[n] / nyquist * M);\n    }\n\n    for (n = 0; n < freq_bands; n++) {\n        //roll out normalised gain of each peak\n        if (style === \"XTRACT_EQUAL_GAIN\") {\n            height = 1;\n            norm_fact = norm;\n        } else {\n            height = 2 / (lin_peak[n + 2] - lin_peak[n]);\n            norm_fact = norm / (2 / (lin_peak[2] - lin_peak[0]));\n        }\n        height_norm[n] = height * norm_fact;\n    }\n    return {\n        f: fft_peak,\n        h: height_norm\n    };\n}\n\nexport function xtract_init_mfcc(N, nyquist, style, freq_min, freq_max, freq_bands) {\n    var mfcc = {\n        n_filters: freq_bands,\n        filters: []\n    };\n    var norm = 1,\n        M = N / 2,\n        height, norm_fact, n;\n\n    if (freq_bands <= 1) {\n        return null;\n    }\n\n    var i = 0,\n        fh = get_fft_peak(N, freq_max, freq_min, freq_bands, nyquist, style),\n        inc;\n    var fft_peak = fh.f,\n        height_norm = fh.h;\n    var next_peak;\n    for (n = 0; n < freq_bands; n++) {\n        // calculate the rise increment\n        if (n === 0) {\n            inc = height_norm[n] / fft_peak[n];\n        } else {\n            inc = height_norm[n] / (fft_peak[n] - fft_peak[n - 1]);\n        }\n        var val = 0;\n        // Create array\n        mfcc.filters[n] = new Float64Array(N);\n        // fill in the rise\n        for (; i <= fft_peak[n]; i++) {\n            mfcc.filters[n][i] = val;\n            val += inc;\n        }\n        // calculate the fall increment\n        inc = height_norm[n] / (fft_peak[n + 1] - fft_peak[n]);\n\n        val = 0;\n        next_peak = fft_peak[n + 1];\n\n        // reverse fill the 'fall'\n        for (i = Math.floor(next_peak); i > fft_peak[n]; i--) {\n            mfcc.filters[n][i] = val;\n            val += inc;\n        }\n    }\n    return mfcc;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_init_pcp(N, fs, f_ref) {\n    if (typeof fs !== \"number\" || typeof N !== \"number\") {\n        throw ('The Sample Rate and sample count have to be defined: xtract_init_pcp(N, fs, f_ref)');\n    }\n    if (N <= 0 || N !== Math.floor(N)) {\n        throw (\"The sample count, N, must be a positive integer: xtract_init_pcp(N, fs, f_ref)\");\n    }\n    if (fs <= 0.0) {\n        throw ('The Sample Rate must be a positive number: xtract_init_pcp(N, fs, f_ref)');\n    }\n    if (typeof f_ref !== \"number\" || f_ref <= 0.0 || f_ref >= fs / 2) {\n        f_ref = 48.9994294977;\n    }\n\n    var M = new Float64Array(N - 1);\n    var fs2 = fs / 2;\n    for (var l = 1; l < N; l++) {\n        var f = (2 * l / N) * fs2;\n        M[l - 1] = Math.round(12 * Math.log2((f / N) * f_ref)) % 12;\n    }\n    return M;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_init_wavelet() {\n    return {\n        _prevPitch: -1,\n        _pitchConfidence: -1\n    };\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_irregularity_j(spectrum) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var num = 0,\n        den = 0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    var amps = spectrum.subarray(0, K);\n    for (var n = 0; n < K - 1; n++) {\n        num += Math.pow(amps[n] - amps[n + 1], 2);\n        den += Math.pow(amps[n], 2);\n    }\n    return num / den;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_irregularity_k(spectrum) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var result = 0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    var amps = spectrum.subarray(0, K);\n    for (var n = 1; n < K - 1; n++) {\n        result += Math.abs(Math.log10(amps[n]) - Math.log10(amps[n - 1] + amps[n] + amps[n + 1]) / 3);\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_is_denormal(num) {\n    if (Math.abs(num) <= 2.2250738585072014e-308) {\n        return true;\n    }\n    return false;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_skewness_kurtosis} from \"./xtract_skewness_kurtosis\";\n\nexport function xtract_kurtosis(array, mean, standard_deviation) {\n    return xtract_skewness_kurtosis(array, mean, standard_deviation)[1];\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_loudness(barkBandsArray) {\n    if (!xtract_assert_array(barkBandsArray))\n        return 0;\n    var result = 0;\n    if (barkBandsArray.reduce) {\n        result = barkBandsArray.reduce(function (a, b) {\n            return a + Math.pow(b, 0.23);\n        }, 0);\n    } else {\n        for (var n = 0; n < barkBandsArray.length; n++) {\n            result += Math.pow(barkBandsArray[n], 0.23);\n        }\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_lowhigh} from \"./xtract_lowhigh\";\n\nexport function xtract_lowest_value(data, threshold) {\n    if (!xtract_assert_array(data))\n        return 0;\n    if (typeof threshold !== \"number\") {\n        threshold = -Infinity;\n    }\n    return xtract_lowhigh(data, threshold).min;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_lowhigh(data, threshold) {\n    var r = {\n        min: null,\n        max: null\n    };\n    for (var n = 0; n < data.length; n++) {\n        if (data[n] > threshold) {\n            r.min = Math.min(r.min, data[n]);\n        }\n        if (data[n] < threshold) {\n            r.max = Math.max(r.max, data[n]);\n        }\n    }\n    return r;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_lpc(autocorr) {\n    if (!xtract_assert_array(autocorr))\n        return 0;\n    var i, j, r, error = autocorr[0];\n    var N = autocorr.length;\n    var L = N - 1;\n    var lpc = new Float64Array(L);\n    var ref = new Float64Array(L);\n    if (error === 0.0) {\n        return lpc;\n    }\n\n    (function () {\n        for (i = 0; i < L; i++) {\n            r = -autocorr[i + 1];\n            for (j = 0; j < i; j++) {\n                r -= lpc[j] * autocorr[i - j];\n            }\n            r /= error;\n            ref[i] = r;\n\n            lpc[i] = r;\n            for (j = 0; j < (i >> 1); j++) {\n                var tmp = lpc[j];\n                lpc[j] += r * lpc[i - 1 - j];\n                lpc[i - 1 - j] += r * tmp;\n            }\n            if (i % 2) {\n                lpc[j] += lpc[j] * r;\n            }\n            error *= 1.0 - r * r;\n        }\n    })();\n    return lpc;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_lpcc(lpc, Q) {\n    if (!xtract_assert_array(lpc))\n        return 0;\n    var N = lpc.length;\n    var n, k, sum, order = N - 1,\n        cep_length;\n    if (typeof Q !== \"number\") {\n        Q = N - 1;\n    }\n    cep_length = Q;\n\n    var result = new Float64Array(cep_length);\n    (function () {\n        for (n = 1; n < Q && n < cep_length; n++) {\n            sum = 0;\n            for (k = 1; k < n; k++) {\n                sum += k * result[k - 1] * lpc[n - k];\n            }\n            result[n - 1] = lpc[n] + sum / n;\n        }\n    })();\n    (function () {\n        for (n = order + 1; n <= cep_length; n++) {\n            sum = 0.0;\n            for (k = n - (order - 1); k < n; k++) {\n                sum += k * result[k - 1] * lpc[n - k];\n            }\n            result[n - 1] = sum / n;\n        }\n    })();\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\nexport function xtract_mean(array) {\n    if (!xtract_assert_array(array))\n        return 0;\n    return xtract_array_sum(array) / array.length;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_dct} from \"./xtract_dct\";\nexport function xtract_mfcc(spectrum, mfcc) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var K = spectrum.length >> 1;\n    if (typeof mfcc !== \"object\") {\n        throw (\"Invalid MFCC, must be MFCC object built using xtract_init_mfcc\");\n    }\n    if (mfcc.n_filters === 0) {\n        throw (\"Invalid MFCC, object must be built using xtract_init_mfcc\");\n    }\n    if (mfcc.filters[0].length !== K) {\n        throw (\"Lengths do not match\");\n    }\n    var result = new Float64Array(mfcc.n_filters);\n    result.forEach(function (v, f, r) {\n        r[f] = 0.0;\n        var filter = mfcc.filters[f];\n        for (var n = 0; n < filter.length; n++) {\n            r[f] += spectrum[n] * filter[n];\n        }\n        r[f] = Math.log(Math.max(r[f], 2e-42));\n    });\n    return xtract_dct(result);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_midicent(f0) {\n    if (typeof f0 !== \"number\") {\n        return -1;\n    }\n    var note = 0.0;\n    note = 69 + Math.log(f0 / 440.0) * 17.31234;\n    note *= 100;\n    note = Math.round(0.5 + note);\n    return note;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_noisiness(h, p) {\n    var i = 0.0;\n    if (typeof h !== \"number\" && typeof p !== \"number\") {\n        return 0;\n    }\n    i = p - h;\n    return i / p;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_nonzero_count(data) {\n    if (!xtract_assert_array(data))\n        return 0;\n    var count = 0;\n    if (data.reduce) {\n        return data.reduce(function (a, b) {\n            if (b !== 0) {\n                a++;\n            }\n            return a;\n        });\n    }\n    for (var n = 0; n < data.length; n++) {\n        if (data[n] !== 0) {\n            count++;\n        }\n    }\n    return count;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_odd_even_ratio(harmonicSpectrum, f0) {\n    if (!xtract_assert_array(harmonicSpectrum))\n        return 0;\n    (function (f0) {\n        if (typeof f0 !== \"number\") {\n            throw (\"spectral_inharmonicity requires f0 to be defined.\");\n        }\n    })(f0);\n    var h = 0,\n        odd = 0.0,\n        even = 0.0,\n        temp;\n    var N = harmonicSpectrum.length;\n    var K = N >> 1;\n    var amps = harmonicSpectrum.subarray(0, n);\n    var freqs = harmonicSpectrum.subarray(n);\n    for (var n = 0; n < K; n++) {\n        temp = amps[n];\n        if (temp !== 0.0) {\n            h = Math.floor(freqs[n] / f0 + 0.5);\n            if (h % 2 !== 0) {\n                odd += temp;\n            } else {\n                even += temp;\n            }\n        }\n    }\n\n    if (odd === 0.0 || even === 0.0) {\n        return 0.0;\n    }\n    return odd / even;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {transform} from \"../freeFFT\";\nimport {xtract_array_interlace} from \"./xtract_array_interlace\";\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_get_data_frames} from \"./xtract_get_data_frames\";\n\nfunction angle(real, imag) {\n    if (imag === undefined && real.length === 2) {\n        return Math.atan2(real[1], real[0]);\n    }\n    return Math.atan2(imag, real);\n}\n\nfunction abs(real, imag) {\n    if (imag === undefined && real.length === 2) {\n        return Math.sqrt(Math.pow(real[0], 2) + Math.pow(real[1], 2));\n    }\n    return Math.sqrt(Math.pow(real, 2) + Math.pow(imag, 2));\n}\n\nfunction princarg(phaseIn) {\n    //phase=mod(phasein+pi,-2*pi)+pi;\n    return (phaseIn + Math.PI) % (-2 * Math.PI) + Math.PI;\n}\n\nfunction complex_mul(cplx_pair_A, cplx_pair_B) {\n    if (cplx_pair_A.length !== 2 || cplx_pair_B.length !== 2) {\n        throw (\"Both arguments must be numeral arrays of length 2\");\n    }\n    var result = new cplx_pair_A.constructor(2);\n    result[0] = cplx_pair_A[0] * cplx_pair_B[0] - cplx_pair_A[1] * cplx_pair_B[1];\n    result[1] = cplx_pair_A[0] * cplx_pair_B[1] + cplx_pair_A[1] * cplx_pair_B[0];\n    return result;\n}\n\nfunction get_X(frames, frameSize) {\n    var N = frames.length;\n    var X = [];\n    var real = new Float64Array(frameSize);\n    var imag = new Float64Array(frameSize);\n    var K = frameSize / 2 + 1;\n    var n;\n    for (var i = 0; i < N; i++) {\n        for (n = 0; n < frameSize; n++) {\n            real[n] = frames[i][n];\n            imag[n] = 0.0;\n        }\n        transform(real, imag);\n        X[i] = xtract_array_interlace([real.subarray(0, K), imag.subarray(0, K)]);\n    }\n    return X;\n}\n\nexport function xtract_onset(timeData, frameSize) {\n\n    if (!xtract_assert_array(timeData))\n        return 0;\n    if (frameSize === undefined) {\n        throw (\"All arguments for xtract_onset must be defined: xtract_onset(timeData, frameSize)\");\n    }\n    var frames = xtract_get_data_frames(timeData, frameSize, frameSize, false);\n    var N = frames.length;\n    var K = frameSize / 2 + 1;\n    var X = get_X(frames, frameSize);\n\n    var E = new timeData.constructor(N);\n    var n;\n    for (var k = 0; k < K; k++) {\n        var phase_prev = angle(X[0].subarray(2 * k, 2 * k + 2));\n        var phase_delta = angle(X[0].subarray(2 * k, 2 * k + 2));\n        for (n = 1; n < N; n++) {\n            var phi = princarg(phase_prev + phase_delta);\n            var exp = [Math.cos(phi), Math.sin(phi)];\n            var XT = complex_mul(X[n].subarray(2 * k, 2 * k + 2), exp);\n            XT[0] = X[n][2 * k] - XT[0];\n            XT[1] = X[n][2 * k + 1] - XT[1];\n            E[n] += abs(XT);\n            var phase_now = angle(X[n].subarray(2 * k, 2 * k + 2));\n            phase_delta = phase_now - phase_prev;\n            phase_prev = phase_now;\n        }\n    }\n\n    for (n = 0; n < N; n++) {\n        E[n] /= frameSize;\n    }\n    return E;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_init_pcp} from \"./xtract_init_pcp\";\nexport function xtract_pcp(spectrum, M, fs) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var N = spectrum.length >> 1;\n    if (typeof M !== \"object\") {\n        if (typeof fs !== \"number\" || fs <= 0.0) {\n            throw (\"Cannot dynamically compute M if fs is undefined / not a valid sample rate\");\n        }\n        M = xtract_init_pcp(N, fs);\n    }\n    var amps = spectrum.subarray(1, N);\n    var PCP = new Float64Array(12);\n    for (var l = 0; l < amps.length; l++) {\n        var p = M[l];\n        PCP[l] += Math.pow(Math.abs(amps[l]), 2);\n    }\n    return PCP;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_max} from \"./xtract_array_max\";\n\nexport function xtract_peak_spectrum(spectrum, q, threshold) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    var max = 0.0,\n        y = 0.0,\n        y2 = 0.0,\n        y3 = 0.0,\n        p = 0.0;\n    if (typeof q !== \"number\") {\n        throw (\"xtract_peak_spectrum requires second argument to be sample_rate/N\");\n    }\n    if (threshold < 0 || threshold > 100) {\n        threshold = 0;\n    }\n    var result = new Float64Array(N);\n    var ampsIn = spectrum.subarray(0, K);\n    var freqsIn = spectrum.subarray(K);\n    var ampsOut = result.subarray(0, K);\n    var freqsOut = result.subarray(K);\n    max = xtract_array_max(ampsIn);\n    threshold *= 0.01 * max;\n    for (var n = 1; n < N - 1; n++) {\n        if (ampsIn[n] >= threshold) {\n            if (ampsIn[n] > ampsIn[n - 1] && ampsIn[n] > ampsIn[n + 1]) {\n                y = ampsIn[n - 1];\n                y2 = ampsIn[n];\n                y3 = ampsIn[n + 1];\n                p = 0.5 * (y - y3) / (ampsIn[n - 1] - 2 * (y2 + ampsIn[n + 1]));\n                freqsOut[n] = q * (n + 1 + p);\n                ampsOut[n] = y2 - 0.25 * (y - y3) * p;\n            } else {\n                ampsOut[n] = 0;\n                freqsOut[n] = 0;\n            }\n        } else {\n            ampsOut[n] = 0;\n            freqsOut[n] = 0;\n        }\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nexport function xtract_power(magnitudeArray) {\n    return null;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_get_data_frames} from \"./xtract_get_data_frames\";\nimport {xtract_spectrum} from \"./xtract_spectrum\";\nexport function xtract_process_frame_data(array, func, sample_rate, frame_size, hop_size, arg_this) {\n    var frames = xtract_get_data_frames(array, frame_size, hop_size);\n    var result = {\n        num_frames: frames.length,\n        results: []\n    };\n    var frame_time = 0;\n    var data = {\n        frame_size: frame_size,\n        hop_size: hop_size,\n        sample_rate: sample_rate,\n        TimeData: undefined,\n        SpectrumData: undefined\n    };\n    var prev_data;\n    var prev_result;\n    for (var fn = 0; fn < frames.length; fn++) {\n        var frame = frames[fn];\n        data.TimeData = frame;\n        data.SpectrumData = xtract_spectrum(frame, sample_rate, true, false);\n        prev_result = func.call(arg_this || this, data, prev_data, prev_result);\n        var frame_result = {\n            time_start: frame_time,\n            result: prev_result\n        };\n        frame_time += frame_size / sample_rate;\n        prev_data = data;\n        data = {\n            frame_size: frame_size,\n            hop_size: hop_size,\n            sample_rate: sample_rate,\n            TimeData: undefined,\n            SpectrumData: undefined\n        };\n        result.results.push(frame_result);\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {transform, inverseTransform} from \"../freeFFT\";\nimport {xtract_get_data_frames} from \"./xtract_get_data_frames\";\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nfunction filter(N, c) {\n    var c_b, Re, Im, b;\n    c_b = Math.floor(c * N);\n    Re = new Float64Array(N);\n    Im = new Float64Array(N);\n    var i, j;\n    for (i = 0; i < c_b; i++) {\n        Re[i] = 1;\n    }\n    for (i = N - c_b + 1; i < N; i++) {\n        Re[i] = 1;\n    }\n    inverseTransform(Re, Im);\n    // Scale and shift into Im\n    for (i = 0; i < N; i++) {\n        j = (i + (N >> 1)) % N;\n        Im[i] = Re[j] / N;\n        // Apply compute blackman-harris to Im\n        var rad = (Math.PI * i) / (N);\n        Im[i] *= 0.35875 - 0.48829 * Math.cos(2 * rad) + 0.14128 * Math.cos(4 * rad) - 0.01168 * Math.cos(6 * rad);\n    }\n    return Im;\n}\n\nfunction polyn(data, K) {\n    var N = data.length;\n    var x = [0, data[0], data[1]];\n    var dst = new Float64Array(K);\n    var ratio = K / N;\n    var tinc = 1 / ratio;\n    var n = 0,\n        t = 0,\n        k;\n    for (k = 0; k < K; k++) {\n        if (t === n) {\n            // Points lie on same time\n            dst[k] = data[n];\n        } else {\n            var y = (t - n - 1) * (t - n) * x[0] - 2 * (t - n - 1) * (t - n + 1) * x[1] + (t - n) * (t - n + 1) * x[2];\n            dst[k] = y / 2;\n        }\n        t += tinc;\n        if (t >= n + 1) {\n            n = Math.floor(t);\n            x[0] = data[n - 1];\n            x[1] = data[n];\n            if (n + 1 < N) {\n                x[2] = data[n + 1];\n            } else {\n                x[2] = 0.0;\n            }\n        }\n    }\n    return dst;\n}\n\nfunction zp(a) {\n    var b = new Float64Array(a.length * 2);\n    for (var n = 0; n < a.length; n++) {\n        b[n] = a[n];\n    }\n    return b;\n}\n\nfunction r2c(x) {\n    var real = zp(x);\n    var imag = new Float64Array(real.length);\n    transform(real, imag);\n    return {\n        real: real,\n        imag: imag\n    };\n}\n\nfunction W(N) {\n    var w = new Float64Array(N),\n        i;\n    for (i = 0; i < N; i++) {\n        var rad = (Math.PI * i) / (N);\n        w[i] = 0.35875 - 0.48829 * Math.cos(2 * rad) + 0.14128 * Math.cos(4 * rad) - 0.01168 * Math.cos(6 * rad);\n    }\n    return w;\n}\n\nfunction overlap(X, b) { // eslint-disable-line max-statements\n    var i, f;\n    var Y = new Float64Array(X.length);\n    var N = b.length;\n    var N2 = 2 * N;\n    var B = r2c(b);\n    var Xi = xtract_get_data_frames(X, N, N, false);\n    var Yi = xtract_get_data_frames(Y, N, N, false);\n    var x_last = new Float64Array(N);\n    var y_last = new Float64Array(N);\n    var w = W(N2);\n    var xF = {\n        real: new Float64Array(N2),\n        imag: new Float64Array(N2)\n    };\n    var yF = {\n        real: new Float64Array(N2),\n        imag: new Float64Array(N2)\n    };\n    for (f = 0; f < Xi.length; f++) {\n        for (i = 0; i < N; i++) {\n            xF.real[i] = x_last[i] * w[i];\n            xF.real[i + N] = Xi[f][i] * w[i + N];\n            x_last[i] = Xi[f][i];\n            xF.imag[i] = 0;\n            xF.imag[i + N] = 0;\n        }\n        transform(xF.real, xF.imag);\n        for (i = 0; i < N2; i++) {\n            yF.real[i] = xF.real[i] * B.real[i] - xF.imag[i] * B.imag[i];\n            yF.imag[i] = xF.imag[i] * B.real[i] + xF.real[i] * B.imag[i];\n        }\n        transform(yF.imag, yF.real);\n        // Perform fft_shift and scale\n        for (i = 0; i < N; i++) {\n            var h = yF.real[i + N] / N;\n            yF.real[i + N] = yF.real[i] / N;\n            yF.real[i] = h;\n        }\n        for (i = 0; i < N; i++) {\n            Yi[f][i] = (yF.real[i] + y_last[i]);\n            y_last[i] = yF.real[i + N];\n        }\n    }\n    return Y;\n}\n\nexport function xtract_resample(data, p, q, n) {\n    if (!xtract_assert_array(data))\n        return 0;\n    // Same function call as matlab:\n    // data is the array\n    // p is the target sample rate\n    // q is the source sample rate\n    // n is the desired filter order, n==1024 if undefined\n\n    // Determine which way to go\n    var b, N = data.length;\n    if (typeof n !== \"number\" || n <= 0) {\n        n = 512;\n    }\n    if (p === q) {\n        return data;\n    }\n    var ratio = (p / q);\n    var K = Math.floor(N * ratio);\n    var dst;\n    if (p > q) {\n        // Upsampling\n        // 1. Expand Data range\n        dst = polyn(data, K);\n        // 2. Filter out spurious energy above q\n        b = filter(n, 1 / ratio);\n        overlap(data, b);\n    } else {\n        // Downsampling\n        // 1. Filter out energy above p\n        b = filter(n, ratio / 2);\n        var ds1 = overlap(data, b);\n        // 2. Decrease data range\n        dst = polyn(ds1, K);\n    }\n    return dst;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_rms_amplitude(timeArray) {\n    if (!xtract_assert_array(timeArray))\n        return 0;\n    var result = 0;\n    if (timeArray.reduce) {\n        result = timeArray.reduce(function (a, b) {\n            return a + b * b;\n        }, 0);\n    } else {\n        for (var n = 0; n < timeArray.length; n++) {\n            result += timeArray[n] * timeArray[n];\n        }\n    }\n    return Math.sqrt(result / timeArray.length);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\n\nexport function xtract_rolloff(spectrum, sampleRate, threshold) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    if (typeof sampleRate !== \"number\" || typeof threshold !== \"number\") {\n        console.log(\"xtract_rolloff requires sampleRate and threshold to be defined\");\n        return null;\n    }\n    var N = spectrum.length;\n    var K = N >> 1;\n    var amps = spectrum.subarray(0, K);\n\n    var pivot = 0,\n        temp = 0;\n\n    pivot = xtract_array_sum(amps);\n\n    pivot *= threshold / 100.0;\n    var n = 0;\n    while (temp < pivot) {\n        temp += amps[n];\n        n++;\n    }\n    return n * (sampleRate / (spectrum.length));\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_sharpness(barkBandsArray) {\n    if (!xtract_assert_array(barkBandsArray))\n        return 0;\n    var N = barkBandsArray.length;\n\n    var rv, sl = 0.0,\n        g = 0.0,\n        temp = 0.0;\n    for (var n = 0; n < N; n++) {\n        sl = Math.pow(barkBandsArray[n], 0.23);\n        g = (n < 15 ? 1.0 : 0.066 * Math.exp(0.171 * n));\n        temp += n * g * sl;\n    }\n    temp = 0.11 * temp / N;\n    return temp;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_skewness_kurtosis} from \"./xtract_skewness_kurtosis\";\nexport function xtract_skewness(array, mean, standard_deviation) {\n    return xtract_skewness_kurtosis(array, mean, standard_deviation)[0];\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_mean} from \"./xtract_mean\";\nimport {xtract_standard_deviation} from \"./xtract_standard_deviation\";\nimport {xtract_variance} from \"./xtract_variance\";\n\nexport function xtract_skewness_kurtosis(array, mean, standard_deviation) {\n    if (!xtract_assert_array(array))\n        return [0.0, 0.0];\n    if (typeof mean !== \"number\") {\n        mean = xtract_mean(array);\n    }\n    if (typeof standard_deviation !== \"number\") {\n        standard_deviation = xtract_standard_deviation(array, xtract_variance(array, mean));\n    }\n    if (standard_deviation === 0) {\n        return [0.0, 0.0];\n    }\n    var result = [0.0, 0.0];\n    for (var n = 0; n < array.length; n++) {\n        result[0] += Math.pow((array[n] - mean) / standard_deviation, 3);\n        result[1] += Math.pow((array[n] - mean) / standard_deviation, 4);\n    }\n    result[0] /= array.length;\n    result[1] /= array.length;\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_smoothness(spectrum) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var prev = 0,\n        current = 0,\n        next = 0,\n        temp = 0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    prev = Math.max(1e-5, spectrum[0]);\n    current = Math.max(1e-5, spectrum[1]);\n    for (var n = 1; n < K - 1; n++) {\n        next = Math.max(1e-5, spectrum[n + 1]);\n        temp += Math.abs(20.0 * Math.log(current) - (20.0 * Math.log(prev) + 20.0 * Math.log(current) + 20.0 * Math.log(next)) / 3.0);\n        prev = current;\n        current = next;\n    }\n    return temp;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\nexport function xtract_spectral_centroid(spectrum) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var N = spectrum.length;\n    var n = N >> 1;\n    var amps = spectrum.subarray(0, n);\n    var freqs = spectrum.subarray(n);\n    var A_d = xtract_array_sum(amps);\n    if (A_d === 0.0) {\n        return 0.0;\n    }\n    var sum = 0.0;\n    while (n--) {\n        sum += freqs[n] * (amps[n] / A_d);\n    }\n    return sum;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {inverseTransform} from \"../freeFFT.js\";\nfunction peak_picking(E, window) {\n    var o = [],\n        N = E.length,\n        n;\n    if (window === undefined) {\n        window = 5;\n    }\n    for (n = window; n < N - window - 1; n++) {\n        var max = 1,\n            m;\n        for (m = -window; m < window - 1; m++) {\n            if (E[n + m] > E[n]) {\n                max = 0;\n                break;\n            }\n        }\n        if (max === 1) {\n            o.push(n);\n        }\n    }\n    return o;\n}\n\nexport function xtract_spectral_fundamental(spectrum, sample_rate) {\n    // Based on work by Motegi and Shimamura\n    if (!xtract_assert_array(spectrum))\n        return 0;\n\n    var N = spectrum.length >> 1;\n    var amps = spectrum.subarray(0, N);\n    var freqs = spectrum.subarray(N);\n    var K = N * 2;\n\n    // Create the power spectrum\n    var power = new Float64Array(K);\n    var n;\n    for (n = 0; n < N; n++) {\n        power[n] = Math.pow(amps[n], 2);\n        power[K - 1 - n] = power[n];\n    }\n\n    // Perform autocorrelation using IFFT\n    var R = new Float64Array(K);\n    inverseTransform(power, R);\n    R = undefined;\n    R = power;\n    power = undefined;\n\n    // Get the peaks\n    var p = peak_picking(R, 5);\n    if (p.length === 0) {\n        return 0;\n    }\n    p = p[0];\n\n    p = p / sample_rate;\n    p = 1 / p;\n    return p;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_spectral_inharmonicity(peakSpectrum, f0) {\n    if (!xtract_assert_array(peakSpectrum))\n        return 0;\n    if (typeof f0 !== \"number\") {\n        console.error(\"spectral_inharmonicity requires f0 to be defined.\");\n        return null;\n    }\n    var h = 0,\n        num = 0.0,\n        den = 0.0;\n    var N = peakSpectrum.length;\n    var K = N >> 1;\n    var amps = peakSpectrum.subarray(0, n);\n    var freqs = peakSpectrum.subarray(n);\n    for (var n = 0; n < K; n++) {\n        if (amps[n] !== 0.0) {\n            h = Math.floor(freqs[n] / f0 + 0.5);\n            var mag_sq = Math.pow(amps[n], 2);\n            num += Math.abs(freqs[n] - h * f0) * mag_sq;\n            den += mag_sq;\n        }\n    }\n    return (2 * num) / (f0 * den);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_spectral_centroid} from \"./xtract_spectral_centroid\";\nimport {xtract_spectral_standard_deviation} from \"./xtract_spectral_standard_deviation\";\nimport {xtract_spectral_variance} from \"./xtract_spectral_variance\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\n\nexport function xtract_spectral_kurtosis(spectrum, spectral_centroid, spectral_standard_deviation) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    if (typeof spectral_centroid !== \"number\") {\n        spectral_centroid = xtract_spectral_centroid(spectrum);\n    }\n    if (typeof spectral_standard_deviation !== \"number\") {\n        spectral_standard_deviation = xtract_spectral_standard_deviation(spectrum, xtract_spectral_variance(spectrum, spectral_centroid));\n    }\n    if (spectral_standard_deviation === 0) {\n        return Infinity;\n    }\n    var result = 0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    var amps = spectrum.subarray(0, K);\n    var freqs = spectrum.subarray(K);\n    var A_d = xtract_array_sum(amps);\n    for (var n = 0; n < K; n++) {\n        result += Math.pow(freqs[n] - spectral_centroid, 4) * (amps[n] / A_d);\n    }\n    return result / Math.pow(spectral_standard_deviation, 4);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\n\nexport function xtract_spectral_mean(spectrum) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var N = spectrum.length;\n    var n = N >> 1;\n    var amps = spectrum.subarray(0, n);\n    var sum = xtract_array_sum(amps);\n    var result = sum / n;\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_spectral_centroid} from \"./xtract_spectral_centroid\";\nimport {xtract_spectral_standard_deviation} from \"./xtract_spectral_standard_deviation\";\nimport {xtract_spectral_variance} from \"./xtract_spectral_variance\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\n\nexport function xtract_spectral_skewness(spectrum, spectral_centroid, spectral_standard_deviation) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    if (typeof spectral_mean !== \"number\") {\n        spectral_centroid = xtract_spectral_centroid(spectrum);\n    }\n    if (typeof spectral_standard_deviation !== \"number\") {\n        spectral_standard_deviation = xtract_spectral_standard_deviation(spectrum, xtract_spectral_variance(spectrum, spectral_centroid));\n    }\n    if (spectral_standard_deviation === 0) {\n        return 0;\n    }\n    var result = 0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    var amps = spectrum.subarray(0, K);\n    var freqs = spectrum.subarray(K);\n    var A_d = xtract_array_sum(amps);\n    for (var n = 0; n < K; n++) {\n        result += Math.pow(freqs[n] - spectral_centroid, 3) * (amps[n] / A_d);\n    }\n    result /= Math.pow(spectral_standard_deviation, 3);\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\n\nexport function xtract_spectral_slope(spectrum) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    var F = 0.0,\n        FA = 0.0,\n        A = 0.0,\n        FXTRACT_SQ = 0.0;\n    var N = spectrum.length;\n    var M = N >> 1;\n    var amps = spectrum.subarray(0, M);\n    var freqs = spectrum.subarray(M);\n    F = xtract_array_sum(freqs);\n    A = xtract_array_sum(amps);\n    for (var n = 0; n < M; n++) {\n        FA += freqs[n] * amps[n];\n        FXTRACT_SQ += freqs[n] * freqs[n];\n    }\n    return (1.0 / A) * (M * FA - F * A) / (M * FXTRACT_SQ - F * F);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_spectral_variance} from \"./xtract_spectral_variance\";\nexport function xtract_spectral_spread(spectrum, spectral_centroid) {\n    return xtract_spectral_variance(spectrum, spectral_centroid);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_spectral_variance} from \"./xtract_spectral_variance\";\nexport function xtract_spectral_standard_deviation(spectrum, spectral_variance) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    if (typeof spectral_variance !== \"number\") {\n        spectral_variance = xtract_spectral_variance(spectrum);\n    }\n    return Math.sqrt(spectral_variance);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_spectral_centroid} from \"./xtract_spectral_centroid\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\nexport function xtract_spectral_variance(spectrum, spectral_centroid) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    if (typeof spectral_centroid !== \"number\") {\n        spectral_centroid = xtract_spectral_centroid(spectrum);\n    }\n    var A = 0,\n        result = 0;\n    var N = spectrum.length;\n    var n = N >> 1;\n    var amps = spectrum.subarray(0, n);\n    var freqs = spectrum.subarray(n, N);\n    var A_d = xtract_array_sum(amps);\n    while (n--) {\n        result += Math.pow(freqs[n] - spectral_centroid, 2) * (amps[n] / A_d);\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_normalise} from \"./xtract_array_normalise\";\nimport {transform} from \"../freeFFT\";\n\nexport function xtract_spectrum(array, sample_rate, withDC, normalise) {\n    (function (array, sample_rate) {\n        if (typeof sample_rate !== \"number\") {\n            throw (\"Sample Rate must be defined\");\n        }\n    })(array, sample_rate);\n    if (!xtract_assert_array(array)) {\n        return 0;\n    }\n    withDC = (withDC === true);\n    normalise = (normalise === true);\n\n    var N = array.length;\n    var result, align = 0;\n    var amps;\n    var freqs;\n    if (withDC) {\n        result = new Float64Array(N + 2);\n    } else {\n        align = 1;\n        result = new Float64Array(N);\n    }\n    amps = result.subarray(0, result.length / 2);\n    freqs = result.subarray(result.length / 2);\n    var reals = new Float64Array(N);\n    var imags = new Float64Array(N);\n    array.forEach(function (v, i) {\n        reals[i] = v;\n    });\n    transform(reals, imags);\n    for (var k = align; k <= result.length / 2; k++) {\n        amps[k - align] = Math.sqrt((reals[k] * reals[k]) + (imags[k] * imags[k])) / array.length;\n        freqs[k - align] = (2 * k / N) * (sample_rate / 2);\n    }\n    if (normalise) {\n        amps = xtract_array_normalise(amps);\n    }\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_variance} from \"./xtract_variance\";\nexport function xtract_standard_deviation(array, variance) {\n    if (!xtract_assert_array(array))\n        return 0;\n    if (typeof variance !== \"number\") {\n        variance = xtract_variance(array);\n    }\n    return Math.sqrt(variance);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\n\nexport function xtract_sum(data) {\n    if (!xtract_assert_array(data))\n        return 0;\n    return xtract_array_sum(data);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_array_sum} from \"./xtract_array_sum\";\nexport function xtract_temporal_centroid(energyArray, sample_rate, window_ms) {\n    if (typeof sample_rate !== \"number\") {\n        console.error(\"xtract_temporal_centroid requires sample_rate to be a number\");\n        return;\n    }\n    if (typeof window_ms !== \"number\") {\n        console.log(\"xtract_temporal_centroid assuming window_ms = 100ms\");\n        window_ms = 100.0;\n    }\n    if (window_ms <= 0) {\n        window_ms = 100.0;\n    }\n    var ts = 1.0 / sample_rate;\n    var L = sample_rate * (window_ms / 1000.0);\n    var den = xtract_array_sum(energyArray);\n    var num = 0.0;\n    for (var n = 0; n < energyArray.length; n++) {\n        num += energyArray[n] * (n * L * ts);\n    }\n    var result = num / den;\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_flatness_db} from \"./xtract_flatness_db\";\n\nexport function xtract_tonality(spectrum, flatness_db) {\n    if (!xtract_assert_array(spectrum))\n        return 0;\n    if (typeof flatness_db !== \"number\") {\n        flatness_db = xtract_flatness_db(spectrum);\n    }\n    return Math.min(flatness_db / -60.0, 1);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_tristimulus(spectrum, f0) {\n    var trist = [0.0, 0.0, 0.0];\n    if (!xtract_assert_array(spectrum))\n        return trist;\n    if (typeof f0 !== \"number\") {\n        throw (\"xtract_tristimulus requires f0 to be defined and a number\");\n    }\n    var h = 0,\n        den = 0.0,\n        p = [0, 0, 0, 0, 0],\n        temp = 0.0,\n        num = 0.0;\n    var N = spectrum.length;\n    var K = N >> 1;\n    var amps = spectrum.subarray(0, K);\n    var freqs = spectrum.subarray(K);\n\n    for (var i = 0; i < K; i++) {\n        temp = amps[i];\n        if (temp !== 0) {\n            den += temp;\n            h = Math.floor(freqs[i] / f0 + 0.5);\n            p[h - 1] += temp;\n        }\n    }\n\n    if (den !== 0.0) {\n        trist[0] = p[0] / den;\n        trist[1] = (p[1] + p[2] + p[3]) / den;\n        trist[2] = p[4] / den;\n    }\n    return trist;\n}\n\nexport function xtract_tristimulus_1(spectrum, f0) {\n    return xtract_tristimulus(spectrum, f0)[0];\n}\n\nexport function xtract_tristimulus_2(spectrum, f0) {\n    return xtract_tristimulus(spectrum, f0)[1];\n}\n\nexport function xtract_tristimulus_3(spectrum, f0) {\n    return xtract_tristimulus(spectrum, f0)[2];\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_mean} from \"./xtract_mean\";\n\nexport function xtract_variance(array, mean) {\n    if (!xtract_assert_array(array))\n        return 0;\n    if (typeof mean !== \"number\") {\n        mean = xtract_mean(array);\n    }\n    if (!xtract_assert_array(array))\n        return 0;\n    if (typeof mean !== \"number\") {\n        mean = xtract_mean(array);\n    }\n    var result = 0.0;\n    if (array.reduce) {\n        result = array.reduce(function (a, b) {\n            a += Math.pow(b - mean, 2);\n            return a;\n        }, 0);\n    } else {\n        for (var n = 0; n < array.length; n++) {\n            result += Math.pow(array[n] - mean, 2);\n        }\n    }\n    result /= (array.length - 1);\n    return result;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nimport {xtract_array_sum} from \"./xtract_array_sum\";\nimport {xtract_mean} from \"./xtract_mean\";\n\nexport function xtract_wavelet_f0(timeArray, sampleRate, pitchtracker) { // eslint-disable-line max-statements\n    if (!xtract_assert_array(timeArray))\n        return 0;\n    if (pitchtracker === undefined) {\n        throw (\"xtract_wavelet_f0 requires pitchtracker to be defined\");\n    }\n    if (xtract_array_sum(timeArray) === 0) {\n        return;\n    }\n\n    function _power2p(value) {\n        if (value === 0) {\n            return 1;\n        }\n        if (value === 2) {\n            return 1;\n        }\n        if (value & 0x1) {\n            return 0;\n        }\n        return (_power2p(value >> 1));\n    }\n\n    function _bitcount(value) {\n        if (value === 0) {\n            return 0;\n        }\n        if (value === 1) {\n            return 1;\n        }\n        if (value === 2) {\n            return 2;\n        }\n        return _bitcount(value >> 1) + 1;\n    }\n\n    function _ceil_power2(value) {\n        if (_power2p(value)) {\n            return value;\n        }\n\n        if (value === 1) {\n            return 2;\n        }\n        var j, i = _bitcount(value);\n        var res = 1;\n        for (j = 0; j < i; j++) {\n            res <<= 1;\n        }\n        return res;\n    }\n\n    function _floor_power2(value) {\n        if (_power2p(value)) {\n            return value;\n        }\n        return _ceil_power2(value) / 2;\n    }\n\n    function _iabs(x) {\n        if (x >= 0) return x;\n        return -x;\n    }\n\n    function _2power(i) {\n        var res = 1,\n            j;\n        for (j = 0; j < i; j++) {\n            res <<= 1;\n        }\n        return res;\n    }\n\n    function dywapitch_neededsamplecount(minFreq) {\n        var nbSam = 3 * 44100 / minFreq; // 1017. for 130 Hz\n        nbSam = _ceil_power2(nbSam); // 1024\n        return nbSam;\n    }\n\n    function bodyLoop() { // eslint-disable-line max-statements\n        delta = Math.floor(44100 / (_2power(curLevel) * 3000));\n        if (curSamNb < 2) {\n            cont = false;\n            return;\n        }\n        var dv, previousDV = -1000;\n        var nbMins = 0,\n            nbMaxs = 0;\n        var lastMinIndex = -1000000;\n        var lastmaxIndex = -1000000;\n        var findMax = 0;\n        var findMin = 0;\n        (function () { // eslint-disable-line complexity\n            for (i = 2; i < curSamNb; i++) {\n                si = sam[i] - theDC;\n                si1 = sam[i - 1] - theDC;\n\n                if (si1 <= 0 && si > 0) {\n                    findMax = 1;\n                }\n                if (si1 >= 0 && si < 0) {\n                    findMin = 1;\n                }\n\n                // min or max ?\n                dv = si - si1;\n\n                if (previousDV > -1000) {\n\n                    if (findMin && previousDV < 0 && dv >= 0) {\n                        // minimum\n                        if (Math.abs(si) >= ampltitudeThreshold) {\n                            if (i > lastMinIndex + delta) {\n                                mins[nbMins++] = i;\n                                lastMinIndex = i;\n                                findMin = 0;\n                            }\n                        }\n                    }\n\n                    if (findMax && previousDV > 0 && dv <= 0) {\n                        // maximum\n                        if (Math.abs(si) >= ampltitudeThreshold) {\n                            if (i > lastmaxIndex + delta) {\n                                maxs[nbMaxs++] = i;\n                                lastmaxIndex = i;\n                                findMax = 0;\n                            }\n                        }\n                    }\n                }\n\n                previousDV = dv;\n            }\n        })();\n\n        if (nbMins === 0 && nbMaxs === 0) {\n            cont = false;\n            return;\n        }\n\n        var d;\n        //memset(distances, 0, samplecount*sizeof(int));\n        var distances = new Int32Array(samplecount);\n        (function () {\n            for (i = 0; i < nbMins; i++) {\n                for (j = 1; j < 3; j++) {\n                    if (i + j < nbMins) {\n                        d = _iabs(mins[i] - mins[i + j]);\n                        distances[d] = distances[d] + 1;\n                    }\n                }\n            }\n            for (i = 0; i < nbMaxs; i++) {\n                for (j = 1; j < 3; j++) {\n                    if (i + j < nbMaxs) {\n                        d = _iabs(maxs[i] - maxs[i + j]);\n                        //asLog(\"dywapitch i=%ld j=%ld d=%ld\\n\", i, j, d);\n                        distances[d] = distances[d] + 1;\n                    }\n                }\n            }\n        })();\n\n        var bestDistance = -1;\n        var bestValue = -1;\n        (function () {\n            for (i = 0; i < curSamNb; i++) {\n                var summed = 0;\n                for (j = -delta; j <= delta; j++) {\n                    if (i + j >= 0 && i + j < curSamNb)\n                        summed += distances[i + j];\n                }\n                //asLog(\"dywapitch i=%ld summed=%ld bestDistance=%ld\\n\", i, summed, bestDistance);\n                if (summed === bestValue) {\n                    if (i === 2 * bestDistance)\n                        bestDistance = i;\n\n                } else if (summed > bestValue) {\n                    bestValue = summed;\n                    bestDistance = i;\n                }\n            }\n        })();\n        var distAvg = 0.0;\n        var nbDists = 0;\n        (function () {\n            for (j = -delta; j <= delta; j++) {\n                if (bestDistance + j >= 0 && bestDistance + j < samplecount) {\n                    var nbDist = distances[bestDistance + j];\n                    if (nbDist > 0) {\n                        nbDists += nbDist;\n                        distAvg += (bestDistance + j) * nbDist;\n                    }\n                }\n            }\n        })();\n        // this is our mode distance !\n        distAvg /= nbDists;\n\n        // continue the levels ?\n        if (curModeDistance > -1.0) {\n            var similarity = Math.abs(distAvg * 2 - curModeDistance);\n            if (similarity <= 2 * delta) {\n                //if DEBUGG then put \"similarity=\"&similarity&&\"delta=\"&delta&&\"ok\"\n                //asLog(\"dywapitch similarity=%f OK !\\n\", similarity);\n                // two consecutive similar mode distances : ok !\n                pitchF = 44100 / (_2power(curLevel - 1) * curModeDistance);\n                cont = false;\n                return;\n            }\n            //if DEBUGG then put \"similarity=\"&similarity&&\"delta=\"&delta&&\"not\"\n        }\n\n        // not similar, continue next level\n        curModeDistance = distAvg;\n\n        curLevel = curLevel + 1;\n        if (curLevel >= 6) {\n            // put \"max levels reached, exiting\"\n            //asLog(\"dywapitch max levels reached, exiting\\n\");\n            cont = false;\n            return;\n        }\n\n        // downsample\n        if (curSamNb < 2) {\n            //asLog(\"dywapitch not enough samples, exiting\\n\");\n            cont = false;\n            return;\n        }\n        (function () {\n            for (i = 0; i < curSamNb / 2; i++) {\n                sam[i] = (sam[2 * i] + sam[2 * i + 1]) / 2.0;\n            }\n        })();\n        curSamNb /= 2;\n    }\n\n    function _dywapitch_dynamicprocess(pitchtracker, pitch) { // eslint-disable-line complexity\n        if (pitch === 0.0) {\n            return -1.0;\n        }\n\n        var estimatedPitch = -1,\n            acceptedError = 0.2,\n            maxConfidence = 5;\n        if (pitch !== -1) {\n            // I have a pitch here\n\n            if (pitchtracker._prevPitch === -1) {\n                // no Previous\n                estimatedPitch = pitch;\n                pitchtracker._prevPitch = pitch;\n                pitchtracker._pitchConfidence = 1;\n            } else if (Math.abs(pitchtracker._prevPitch - pitch) / pitch < acceptedError) {\n                // similar: remember and increment\n                pitchtracker._prevPitch = pitch;\n                estimatedPitch = pitch;\n                pitchtracker._pitchConfidence = Math.min(maxConfidence, pitchtracker._pitchConfidence + 1);\n            } else if ((pitchtracker._pitchConfidence >= maxConfidence - 2) && Math.abs(pitchtracker._pitchConfidence - 2 * pitch) / (2 * pitch) < acceptedError) {\n                // close to half the last pitch, which is trusted\n                estimatedPitch = 2 * pitch;\n                pitchtracker._prevPitch = estimatedPitch;\n            } else if ((pitchtracker._pitchConfidence >= maxConfidence - 2) && Math.abs(pitchtracker._pitchConfidence - 0.5 * pitch) / (0.5 * pitch) < acceptedError) {\n                estimatedPitch = 0.5 * pitch;\n                pitchtracker._prevPitch = estimatedPitch;\n            } else {\n                // Very different value\n                if (pitchtracker._pitchConfidence >= 1) {\n                    // previous trusted\n                    estimatedPitch = pitchtracker._prevPitch;\n                    pitchtracker._pitchConfidence = Math.max(0, pitchtracker._pitchConfidence - 1);\n                } else {\n                    estimatedPitch = pitch;\n                    pitchtracker._prevPitch = pitch;\n                    pitchtracker._pitchConfidence = 1;\n                }\n            }\n        } else {\n            // No pitch\n            if (pitchtracker._prevPitch !== -1) {\n                // was a pitch before\n                if (pitchtracker._pitchConfidence >= 1) {\n                    // previous trusted\n                    estimatedPitch = pitchtracker._prevPitch;\n                    pitchtracker._pitchConfidence = Math.max(0, pitchtracker._pitchConfidence - 1);\n                } else {\n                    pitchtracker._prevPitch = -1;\n                    estimatedPitch = -1;\n                    pitchtracker._pitchConfidence = 0;\n                }\n            }\n        }\n\n        if (pitchtracker._pitchConfidence >= 1) {\n            pitch = estimatedPitch;\n        } else {\n            pitch = -1;\n        }\n        if (pitch === -1) {\n            pitch = 0.0;\n        }\n        return pitch;\n    }\n\n    var _minmax = {\n        index: undefined,\n        next: undefined\n    };\n    //_dywapitch_computeWaveletPitch(samples, startsample, samplecount)\n    var samples = timeArray,\n        startsample = 0,\n        samplecount = timeArray.length;\n    var pitchF = 0.0;\n    var i, j, si, si1;\n\n    samplecount = _floor_power2(samplecount);\n    var sam = new Float64Array(samplecount);\n    for (i = 0; i < samplecount; i++) {\n        sam[i] = samples[i];\n    }\n\n    var curSamNb = samplecount;\n\n    var mins = new Int32Array(samplecount);\n    var maxs = new Int32Array(samplecount);\n\n    //var maxFLWTlevels = 6;\n    //var maxF = 3000;\n    //var differenceLevelsN = 3;\n    //var maximaThresholdRatio = 0.75;\n    var theDC = getTheDC(sam, samplecount);\n\n    function getTheDC(sam, samplecount) {\n        return xtract_mean(sam.subarray(samplecount));\n    }\n\n    function getamplitudeMax(sam, samplecount) {\n        var si, i;\n        var minValue = 0.0,\n            maxValue = 0.0;\n        for (i = 0; i < samplecount; i++) {\n            si = sam[i];\n            if (si > maxValue) {\n                maxValue = si;\n            }\n            if (si < minValue) {\n                minValue = si;\n            }\n        }\n        maxValue = maxValue - theDC;\n        minValue = minValue - theDC;\n        return (maxValue > -minValue ? maxValue : -minValue);\n    }\n    var ampltitudeThreshold = getamplitudeMax(sam, samplecount) * 0.75;\n\n    var curLevel = 0;\n    var curModeDistance = -1;\n    var delta;\n\n    var cont = true;\n\n    while (cont) {\n        bodyLoop();\n    }\n\n    //_dywapitch_dynamicprocess(pitchtracker, pitch)\n    return _dywapitch_dynamicprocess(pitchtracker, pitchF);\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\n\nexport function xtract_yin(array) {\n    // Uses the YIN process\n    if (!xtract_assert_array(array))\n        return 0;\n    var T = array.length;\n    var d = new Float64Array(array.length);\n    var r = new array.constructor(array.length);\n\n    var d_sigma = 0;\n    for (var tau = 1; tau < T; tau++) {\n        var sigma = 0;\n        for (var t = 1; t < T - tau; t++) {\n            sigma += Math.pow(array[t] - array[t + tau], 2);\n        }\n        d[tau] = sigma;\n        d_sigma += sigma;\n        r[tau] = d[tau] / ((1 / tau) * d_sigma);\n    }\n    return r;\n}\n","/// <reference path=\"../../typings/functions.d.ts\" />\nimport {xtract_assert_array} from \"./xtract_assert_array\";\nexport function xtract_zcr(timeArray) {\n    if (!xtract_assert_array(timeArray))\n        return 0;\n    var result = 0;\n    for (var n = 1; n < timeArray.length; n++) {\n        if (timeArray[n] * timeArray[n - 1] < 0) {\n            result++;\n        }\n    }\n    return result / timeArray.length;\n}\n","import {\n    xtract_is_denormal\n} from \"./functions/xtract_is_denormal\";\nimport {\n    xtract_assert_array\n} from \"./functions/xtract_assert_array\";\nimport {\n    xtract_assert_positive_integer\n} from \"./functions/xtract_assert_positive_integer\";\nimport {\n    xtract_array_sum\n} from \"./functions/xtract_array_sum\";\nimport {\n    xtract_array_copy\n} from \"./functions/xtract_array_copy\";\nimport {\n    xtract_array_min\n} from \"./functions/xtract_array_min\";\nimport {\n    xtract_array_max\n} from \"./functions/xtract_array_max\";\nimport {\n    xtract_array_scale\n} from \"./functions/xtract_array_scale\";\nimport {\n    xtract_array_normalise\n} from \"./functions/xtract_array_normalise\";\nimport {\n    xtract_array_bound\n} from \"./functions/xtract_array_bound\";\nimport {\n    xtract_array_interlace\n} from \"./functions/xtract_array_interlace\";\nimport {\n    xtract_array_deinterlace\n} from \"./functions/xtract_array_deinterlace\";\nimport {\n    xtract_get_number_of_frames\n} from \"./functions/xtract_get_number_of_frames\";\nimport {\n    xtract_get_data_frames\n} from \"./functions/xtract_get_data_frames\";\nimport {\n    xtract_process_frame_data\n} from \"./functions/xtract_process_frame_data\";\nimport {\n    xtract_array_to_JSON\n} from \"./functions/xtract_array_to_JSON\";\nimport {\n    xtract_frame_from_array\n} from \"./functions/xtract_frame_from_array\";\nimport {\n    xtract_mean\n} from \"./functions/xtract_mean\";\nimport {\n    xtract_temporal_centroid\n} from \"./functions/xtract_temporal_centroid\";\nimport {\n    xtract_variance\n} from \"./functions/xtract_variance\";\nimport {\n    xtract_standard_deviation\n} from \"./functions/xtract_standard_deviation\";\nimport {\n    xtract_average_deviation\n} from \"./functions/xtract_average_deviation\";\nimport {\n    xtract_skewness_kurtosis\n} from \"./functions/xtract_skewness_kurtosis\";\nimport {\n    xtract_skewness\n} from \"./functions/xtract_skewness\";\nimport {\n    xtract_kurtosis\n} from \"./functions/xtract_kurtosis\";\nimport {\n    xtract_spectral_centroid\n} from \"./functions/xtract_spectral_centroid\";\nimport {\n    xtract_spectral_mean\n} from \"./functions/xtract_spectral_mean\";\nimport {\n    xtract_spectral_variance\n} from \"./functions/xtract_spectral_variance\";\nimport {\n    xtract_spectral_spread\n} from \"./functions/xtract_spectral_spread\";\nimport {\n    xtract_spectral_standard_deviation\n} from \"./functions/xtract_spectral_standard_deviation\";\nimport {\n    xtract_spectral_skewness\n} from \"./functions/xtract_spectral_skewness\";\nimport {\n    xtract_spectral_kurtosis\n} from \"./functions/xtract_spectral_kurtosis\";\nimport {\n    xtract_irregularity_k\n} from \"./functions/xtract_irregularity_k\";\nimport {\n    xtract_irregularity_j\n} from \"./functions/xtract_irregularity_j\";\nimport {\n    xtract_tristimulus,\n    xtract_tristimulus_1,\n    xtract_tristimulus_2,\n    xtract_tristimulus_3\n} from \"./functions/xtract_tristimulus\";\nimport {\n    xtract_smoothness\n} from \"./functions/xtract_smoothness\";\nimport {\n    xtract_zcr\n} from \"./functions/xtract_zcr\";\nimport {\n    xtract_rolloff\n} from \"./functions/xtract_rolloff\";\nimport {\n    xtract_loudness\n} from \"./functions/xtract_loudness\";\nimport {\n    xtract_flatness\n} from \"./functions/xtract_flatness\";\nimport {\n    xtract_flatness_db\n} from \"./functions/xtract_flatness_db\";\nimport {\n    xtract_tonality\n} from \"./functions/xtract_tonality\";\nimport {\n    xtract_crest\n} from \"./functions/xtract_crest\";\nimport {\n    xtract_noisiness\n} from \"./functions/xtract_noisiness\";\nimport {\n    xtract_rms_amplitude\n} from \"./functions/xtract_rms_amplitude\";\nimport {\n    xtract_spectral_inharmonicity\n} from \"./functions/xtract_spectral_inharmonicity\";\nimport {\n    xtract_power\n} from \"./functions/xtract_power\";\nimport {\n    xtract_odd_even_ratio\n} from \"./functions/xtract_odd_even_ratio\";\nimport {\n    xtract_sharpness\n} from \"./functions/xtract_sharpness\";\nimport {\n    xtract_spectral_slope\n} from \"./functions/xtract_spectral_slope\";\nimport {\n    xtract_lowhigh\n} from \"./functions/xtract_lowhigh\";\nimport {\n    xtract_lowest_value\n} from \"./functions/xtract_lowest_value\";\nimport {\n    xtract_highest_value\n} from \"./functions/xtract_highest_value\";\nimport {\n    xtract_sum\n} from \"./functions/xtract_sum\";\nimport {\n    xtract_nonzero_count\n} from \"./functions/xtract_nonzero_count\";\nimport {\n    xtract_hps\n} from \"./functions/xtract_hps\";\nimport {\n    xtract_f0\n} from \"./functions/xtract_f0\";\nimport {\n    xtract_failsafe_f0\n} from \"./functions/xtract_failsafe_f0\";\nimport {\n    xtract_wavelet_f0\n} from \"./functions/xtract_wavelet_f0\";\nimport {\n    xtract_midicent\n} from \"./functions/xtract_midicent\";\nimport {\n    xtract_spectral_fundamental\n} from \"./functions/xtract_spectral_fundamental\";\nimport {\n    xtract_energy\n} from \"./functions/xtract_energy\";\nimport {\n    xtract_spectrum\n} from \"./functions/xtract_spectrum\";\nimport {\n    xtract_complex_spectrum\n} from \"./functions/xtract_complex_spectrum\";\nimport {\n    xtract_mfcc\n} from \"./functions/xtract_mfcc\";\nimport {\n    xtract_dct\n} from \"./functions/xtract_dct\";\nimport {\n    xtract_dct_2\n} from \"./functions/xtract_dct_2\";\nimport {\n    xtract_autocorrelation\n} from \"./functions/xtract_autocorrelation\";\nimport {\n    xtract_amdf\n} from \"./functions/xtract_amdf\";\nimport {\n    xtract_asdf\n} from \"./functions/xtract_asdf\";\nimport {\n    xtract_bark_coefficients\n} from \"./functions/xtract_bark_coefficients\";\nimport {\n    xtract_peak_spectrum\n} from \"./functions/xtract_peak_spectrum\";\nimport {\n    xtract_harmonic_spectrum\n} from \"./functions/xtract_harmonic_spectrum\";\nimport {\n    xtract_lpc\n} from \"./functions/xtract_lpc\";\nimport {\n    xtract_lpcc\n} from \"./functions/xtract_lpcc\";\nimport {\n    xtract_pcp\n} from \"./functions/xtract_pcp\";\nimport {\n    xtract_yin\n} from \"./functions/xtract_yin\";\nimport {\n    xtract_onset\n} from \"./functions/xtract_onset\";\nimport {\n    xtract_resample\n} from \"./functions/xtract_resample\";\nimport {\n    xtract_init_dft\n} from \"./functions/xtract_init_dft\";\nimport {\n    xtract_init_dct\n} from \"./functions/xtract_init_dct\";\nimport {\n    xtract_init_mfcc\n} from \"./functions/xtract_init_mfcc\";\nimport {\n    xtract_init_wavelet\n} from \"./functions/xtract_init_wavelet\";\nimport {\n    xtract_init_pcp\n} from \"./functions/xtract_init_pcp\";\nimport {\n    xtract_init_bark\n} from \"./functions/xtract_init_bark\";\nimport {\n    xtract_init_chroma\n} from \"./functions/xtract_init_chroma\";\nimport {\n    xtract_apply_window\n} from \"./functions/xtract_apply_window\";\nimport {\n    xtract_create_window\n} from \"./functions/xtract_create_window\";\nimport {\n    xtract_chroma\n} from \"./functions/xtract_chroma\";\n\nimport {\n    HarmonicSpectrumData\n} from \"./objects/HarmonicSpectrumData\";\nimport {\n    PeakSpectrumData\n} from \"./objects/PeakSpectrumData\";\nimport {\n    SpectrumData\n} from \"./objects/SpectrumData\";\nimport {\n    TimeData\n} from \"./objects/TimeData\";\n\n\nif (typeof AnalyserNode !== \"undefined\") {\n\n    AnalyserNode.prototype.timeData = undefined;\n    AnalyserNode.prototype.spectrumData = undefined;\n    AnalyserNode.prototype.callbackObject = undefined;\n    AnalyserNode.prototype.fooGain = undefined;\n    AnalyserNode.prototype.getXtractData = function () {\n        if (this.timeData === undefined || this.scpectrumData === undefined) {\n            this.timeData = new TimeData(this.fftSize, this.context.sampleRate);\n            this.spectrumData = new SpectrumData(this.frequencyBinCount, this.context.sampleRate);\n        }\n        var dst = new Float32Array(this.fftSize);\n        var i;\n        if (this.getFloatTimeDomainData) {\n            this.getFloatTimeDomainData(dst);\n        } else {\n            var view = new Uint8Array(this.fftSize);\n            this.getByteTimeDomainData(view);\n            for (i = 0; i < this.fftSize; i++) {\n                dst[i] = view[i];\n                dst[i] = (dst[i] / 127.5) - 1;\n            }\n        }\n        this.timeData.copyDataFrom(dst);\n        this.timeData.result.spectrum = this.spectrumData;\n        var LogStore = new Float32Array(this.frequencyBinCount);\n        this.getFloatFrequencyData(LogStore);\n        for (i = 0; i < this.frequencyBinCount; i++) {\n            LogStore[i] = Math.pow(10.0, LogStore[i] / 20);\n        }\n        this.spectrumData.copyDataFrom(LogStore);\n        return this.timeData;\n    };\n    AnalyserNode.prototype.previousFrame = undefined;\n    AnalyserNode.prototype.previousResult = undefined;\n    AnalyserNode.prototype.frameCallback = function (func, arg_this) {\n        // Perform a callback on each frame\n        // The function callback has the arguments (current_frame, previous_frame, previous_result)\n        if (this.callbackObject === undefined) {\n            this.callbackObject = this.context.createScriptProcessor(this.fftSize, 1, 1);\n            this.connect(this.callbackObject);\n        }\n        var _func = func;\n        var _arg_this = arg_this;\n        var self = this;\n        this.callbackObject.onaudioprocess = function (e) {\n            var current_frame = self.getXtractData();\n            this.previousResult = _func.call(_arg_this, current_frame, this.previousFrame, this.previousResult);\n            this.previousFrame = current_frame;\n            var N = e.outputBuffer.length;\n            var output = new Float32Array(N);\n            var result = this.previousResult;\n            if (typeof this.previousResult !== \"number\") {\n                result = 0.0;\n            }\n            for (var i = 0; i < N; i++) {\n                output[i] = result;\n            }\n            e.outputBuffer.copyToChannel(output, 0, 0);\n        };\n\n        // For chrome and other efficiency browsers\n        if (!this.fooGain) {\n            this.fooGain = this.context.createGain();\n            this.fooGain.gain.value = 0;\n            this.callbackObject.connect(this.fooGain);\n            this.fooGain.connect(this.context.destination);\n        }\n    };\n\n    AnalyserNode.prototype.clearCallback = function () {\n        this.disconnect(this.callbackObject);\n        this.callbackObject.onaudioprocess = undefined;\n    };\n\n    AnalyserNode.prototype.xtractFrame = function (func, arg_this) {\n        // Collect the current frame of data and perform the callback function\n        func.call(arg_this, this.getXtractData());\n    };\n}\n\nif (typeof AudioBuffer !== \"undefined\") {\n\n    AudioBuffer.prototype.xtract_get_data_frames = function (frame_size, hop_size) {\n        if (hop_size === undefined) {\n            hop_size = frame_size;\n        }\n        (function () {\n            if (!xtract_assert_positive_integer(frame_size)) {\n                throw (\"xtract_get_data_frames requires the frame_size to be defined, positive integer\");\n            }\n            if (!xtract_assert_positive_integer(hop_size)) {\n                throw (\"xtract_get_data_frames requires the hop_size to be a positive integer\");\n            }\n        })();\n        this.frames = [];\n        var N = this.length;\n        var K = this.xtract_get_number_of_frames(hop_size);\n        for (var c = 0; c < this.numberOfChannels; c++) {\n            var data = this.getChannelData(c);\n            this.frames[c] = [];\n            for (var k = 0; k < K; k++) {\n                var frame = new TimeData(frame_size, this.sampleRate);\n                frame.copyDataFrom(data.subarray(hop_size * k, hop_size * k + frame_size));\n                this.frames[c].push(frame);\n                frame = undefined;\n            }\n            data = undefined;\n        }\n        return this.frames;\n    };\n\n    AudioBuffer.prototype.xtract_get_number_of_frames = function (hop_size) {\n        return xtract_get_number_of_frames(this, hop_size);\n    };\n\n    AudioBuffer.prototype.xtract_get_frame = function (dst, channel, index, frame_size) {\n        (function () {\n            if (typeof dst !== \"object\" || dst.constructor !== Float32Array) {\n                throw (\"dst must be a Float32Array object equal in length to hop_size\");\n            }\n            if (!xtract_assert_positive_integer(channel)) {\n                throw (\"xtract_get_frame requires the channel to be an integer value\");\n            }\n            if (!xtract_assert_positive_integer(index)) {\n                throw (\"xtract_get_frame requires the index to be an integer value\");\n            }\n            if (!xtract_assert_positive_integer(frame_size)) {\n                throw (\"xtract_get_frame requires the frame_size to be defined, positive integer\");\n            }\n        })();\n        if (channel < 0 || channel > this.numberOfChannels) {\n            throw (\"channel number \" + channel + \" out of bounds\");\n        }\n        var K = this.xtract_get_number_of_frames(frame_size);\n        if (index < 0 || index >= K) {\n            throw (\"index number \" + index + \" out of bounds\");\n        }\n        return this.copyFromChannel(dst, channel, frame_size * index);\n    };\n\n    AudioBuffer.prototype.xtract_process_frame_data = function () {\n        throw (\"AudioBuffer::xtract_process_frame_data has been deprecated\");\n    };\n}\n\n\nexport {\n    xtract_is_denormal,\n    xtract_assert_array,\n    xtract_assert_positive_integer,\n    xtract_array_sum,\n    xtract_array_copy,\n    xtract_array_min,\n    xtract_array_max,\n    xtract_array_scale,\n    xtract_array_normalise,\n    xtract_array_bound,\n    xtract_array_interlace,\n    xtract_array_deinterlace,\n    xtract_get_number_of_frames,\n    xtract_get_data_frames,\n    xtract_process_frame_data,\n    xtract_array_to_JSON,\n    xtract_frame_from_array,\n    xtract_mean,\n    xtract_temporal_centroid,\n    xtract_variance,\n    xtract_standard_deviation,\n    xtract_average_deviation,\n    xtract_skewness_kurtosis,\n    xtract_skewness,\n    xtract_kurtosis,\n    xtract_spectral_centroid,\n    xtract_spectral_mean,\n    xtract_spectral_variance,\n    xtract_spectral_spread,\n    xtract_spectral_standard_deviation,\n    xtract_spectral_skewness,\n    xtract_spectral_kurtosis,\n    xtract_irregularity_k,\n    xtract_irregularity_j,\n    xtract_tristimulus,\n    xtract_tristimulus_1,\n    xtract_tristimulus_2,\n    xtract_tristimulus_3,\n    xtract_smoothness,\n    xtract_zcr,\n    xtract_rolloff,\n    xtract_loudness,\n    xtract_flatness,\n    xtract_flatness_db,\n    xtract_tonality,\n    xtract_crest,\n    xtract_noisiness,\n    xtract_rms_amplitude,\n    xtract_spectral_inharmonicity,\n    xtract_power,\n    xtract_odd_even_ratio,\n    xtract_sharpness,\n    xtract_spectral_slope,\n    xtract_lowhigh,\n    xtract_lowest_value,\n    xtract_highest_value,\n    xtract_sum,\n    xtract_nonzero_count,\n    xtract_hps,\n    xtract_f0,\n    xtract_failsafe_f0,\n    xtract_wavelet_f0,\n    xtract_midicent,\n    xtract_spectral_fundamental,\n    xtract_energy,\n    xtract_spectrum,\n    xtract_complex_spectrum,\n    xtract_mfcc,\n    xtract_dct,\n    xtract_dct_2,\n    xtract_autocorrelation,\n    xtract_amdf,\n    xtract_asdf,\n    xtract_bark_coefficients,\n    xtract_peak_spectrum,\n    xtract_harmonic_spectrum,\n    xtract_lpc,\n    xtract_lpcc,\n    xtract_pcp,\n    xtract_yin,\n    xtract_onset,\n    xtract_resample,\n    xtract_init_dft,\n    xtract_init_dct,\n    xtract_init_mfcc,\n    xtract_init_wavelet,\n    xtract_init_pcp,\n    xtract_init_bark,\n    xtract_init_chroma,\n    xtract_apply_window,\n    xtract_create_window,\n    xtract_chroma,\n    HarmonicSpectrumData,\n    PeakSpectrumData,\n    SpectrumData,\n    TimeData\n};\n","/// <reference path=\"../../typings/objects/CommonMemory.d.ts\" />\n\nimport {xtract_init_dct} from \"../functions/xtract_init_dct\";\nimport {xtract_init_mfcc} from \"../functions/xtract_init_mfcc\";\nimport {xtract_init_bark} from \"../functions/xtract_init_bark\";\nimport {xtract_init_chroma} from \"../functions/xtract_init_chroma\";\n\nfunction searchMapProperties(map, properties) {\n    var match = map.find(function (e) {\n        for (var prop in properties) {\n            if (e[prop] !== properties[prop]) {\n                return false;\n            }\n        }\n        return true;\n    });\n    return match;\n}\n\nvar dct_map = {\n    parent: this,\n    store: [],\n    createCoefficients: function (N) {\n        var match = searchMapProperties(this.store, {\n            N: N\n        });\n        if (!match) {\n            match = {\n                N: N,\n                data: xtract_init_dct(N)\n            };\n            this.store.push(match);\n        }\n        return match.data;\n    }\n};\n\nvar mfcc_map = {\n    parent: this,\n    store: [],\n    createCoefficients: function (N, nyquist, style, freq_min, freq_max, freq_bands) {\n        var search = {\n            N: N,\n            nyquist: nyquist,\n            style: style,\n            freq_min: freq_min,\n            freq_max: freq_max,\n            freq_bands: freq_bands\n        };\n        var match = searchMapProperties(this.store, search);\n        if (!match) {\n            match = search;\n            match.data = xtract_init_mfcc(N, nyquist, style, freq_min, freq_max, freq_bands);\n            this.store.push(match);\n        }\n        return match.data;\n    }\n};\n\nvar bark_map = {\n    parent: this,\n    store: [],\n    createCoefficients: function (N, sampleRate, numBands) {\n        var search = {\n            N: N,\n            sampleRate: sampleRate,\n            numBands: numBands\n        };\n        var match = searchMapProperties(this.store, search);\n        if (!match) {\n            match = search;\n            match.data = xtract_init_bark(N, sampleRate, numBands);\n            this.store.push(match);\n        }\n        return match.data;\n    }\n};\n\n\nvar chroma_map = {\n    parent: this,\n    store: [],\n    createCoefficients: function (N, sampleRate, nbins, A440, f_ctr, octwidth) {\n        var search = {\n            N: N,\n            sampleRate: sampleRate,\n            nbins: nbins,\n            A440: A440,\n            f_ctr: f_ctr,\n            octwidth: octwidth\n        };\n        var match = searchMapProperties(this.store, search);\n        if (!match) {\n            match = search;\n            match.data = xtract_init_chroma(N, sampleRate, nbins, A440, f_ctr, octwidth);\n            this.store.push(match);\n        }\n        return match.data;\n    }\n};\n\nexport function createDctCoefficients(N) {\n    return dct_map.createCoefficients(N);\n}\n\nexport function createMfccCoefficients(N, nyquist, style, freq_min, freq_max, freq_bands) {\n    return mfcc_map.createCoefficients(N, nyquist, style, freq_min, freq_max, freq_bands);\n}\n\nexport function createBarkCoefficients(N, sampleRate, numBands) {\n    if (typeof numBands !== \"number\" || numBands < 0 || numBands > 26) {\n        numBands = 26;\n    }\n    return bark_map.createCoefficients(N, sampleRate, numBands);\n}\n\nexport function createChromaCoefficients(N, sampleRate, nbins, A440, f_ctr, octwidth) {\n    return chroma_map.createCoefficients(N, sampleRate, nbins, A440, f_ctr, octwidth);\n}\n","/// <reference path=\"../../typings/objects/DataPrototype.d.ts\" />\nimport {xtract_array_to_JSON} from \"../functions/xtract_array_to_JSON\";\nimport {createDctCoefficients, createMfccCoefficients, createBarkCoefficients, createChromaCoefficients} from \"./CommonMemory\";\n\nfunction recursiveDelta(a, b) {\n    //a and b are objects of Time/Spectrum/PeakS/HarmonicS Data\n    //a and b are the .result object\n    var param, delta = {};\n    for (param in a) {\n        if (b[param]) {\n            if (typeof a[param] === \"number\") {\n                delta[param] = a[param] - b[param];\n            } else {\n                delta[param] = deltaObject(a, b, param);\n            }\n        }\n    }\n    return delta;\n}\n\nfunction deltaObject(a, b, param) {\n    if (a.result && b.result) {\n        return recursiveDelta(a[param].result, b[param].result);\n    } else if (a.length && b.length) {\n        return deltaArray(a[param], b[param]);\n    }\n    return undefined;\n}\n\nfunction deltaArray(a, b) {\n    var d;\n    if (a.length === b.length) {\n        d = new Float64Array(a.length);\n    } else {\n        d = [];\n    }\n    var n = 0;\n    while (n < a.length && n < b.length) {\n        d[n] = a[n] - b[n];\n        n++;\n    }\n    return d;\n}\n\nexport class DataPrototype {\n    constructor(N, sampleRate) {\n        this.result = {};\n        this._sampleRate = sampleRate;\n        this.data = new Float64Array(N);\n    }\n    get sampleRate() {\n        return this._sampleRate;\n    }\n    set sampleRate(fs) {\n        this._sampleRate = fs;\n    }\n    clearResult() {\n        this.result = {};\n    }\n    getData() {\n        return this.data;\n    }\n    zeroDataRange(start, end) {\n        if (this.data.fill) {\n            this.data.fill(0, start, end);\n        } else {\n            for (var n = start; n < end; n++) {\n                this.data[n] = 0;\n            }\n        }\n        this.clearResult();\n    }\n    zeroData () {\n        this.zeroDataRange(0, this.data.length);\n    }\n    copyDataFrom(src, N, offset) {\n        if (typeof src !== \"object\" || src.length === undefined) {\n            throw (\"copyDataFrom requires src to be an Array or TypedArray\");\n        }\n        if (offset === undefined) {\n            offset = 0;\n        }\n        if (N === undefined) {\n            N = Math.min(src.length, this.data.length);\n        }\n        N = Math.min(N + offset, this.data.length);\n        for (var n = 0; n < N; n++) {\n            this.data[n + offset] = src[n];\n        }\n        this.clearResult();\n    }\n\n    duplicate() {\n        var copy = this.prototype.constructor(this.data.length, this.sampleRate);\n        copy.copyDataFrom(this.data);\n    }\n\n    toJSON() {\n        function lchar(str) {\n            var lastchar = str[str.length - 1];\n            if (lastchar !== '{' && lastchar !== ',') {\n                str = str + ', ';\n            }\n            return str;\n        }\n\n        function getJSONString(self, p, n) {\n            var str = \"\";\n            if (typeof p === \"number\" && isFinite(p)) {\n                str = '\"' + n + '\": ' + p;\n            } else if (typeof p === \"object\") {\n                if (p.toJSON) {\n                    str = '\"' + n + '\": ' + p.toJSON(p);\n                } else if (p.length) {\n                    str = '\"' + n + '\": ' + xtract_array_to_JSON(p);\n                } else {\n                    str = '\"' + n + '\": ' + self.toJSON(p);\n                }\n            } else {\n                str = '\"' + n + '\": \"' + p.toString() + '\"';\n            }\n            return str;\n        }\n        var json = '{';\n        for (var property in this.result) {\n            if (this.result.hasOwnProperty(property)) {\n                json = lchar(json);\n                json = json + getJSONString(this, this.result[property], property);\n            }\n        }\n        return json + '}';\n    }\n\n    computeDelta(compare) {\n        this.result.delta = recursiveDelta(this.result, compare.result);\n        return this.result.delta;\n    }\n\n    computeDeltaDelta(compare) {\n        if (!compare.result.delta || !this.result.delta) {\n            throw (\"Cannot compute delta-delta without both objects having deltas\");\n        }\n        this.result.delta.delta = recursiveDelta(this.result.delta, compare.result.delta);\n        return this.result.delta.delta;\n    }\n\n    createDctCoefficients(N) {\n        return createDctCoefficients(Number(N));\n    }\n\n    createMfccCoefficients(N, nyquist, style, freq_min, freq_max, freq_bands) {\n        N = Number(N);\n        nyquist = Number(nyquist);\n        freq_min = Number(freq_min);\n        freq_max = Number(freq_max);\n        freq_bands = Number(freq_bands);\n        return createMfccCoefficients(N, nyquist, style, freq_min, freq_max, freq_bands);\n    }\n\n    createBarkCoefficients(N, sampleRate, numBands) {\n        N = Number(N);\n        sampleRate = Number(sampleRate);\n        numBands = Number(numBands);\n        return createBarkCoefficients(N, sampleRate, numBands);\n    }\n\n    createChromaCoefficients(N, sampleRate, nbins, A440, f_ctr, octwidth) {\n        N = Number(N);\n        sampleRate = Number(sampleRate);\n        nbins = Number(nbins);\n        A440 = Number(A440);\n        f_ctr = Number(f_ctr);\n        octwidth = Number(octwidth);\n        return createChromaCoefficients(N, sampleRate, nbins, A440, f_ctr, octwidth);\n    }\n}\n","/// <reference path=\"../../typings/objects/PeakSpectrumData.d.ts\" />\nimport {PeakSpectrumData} from \"./PeakSpectrumData\";\nimport {xtract_odd_even_ratio} from \"../functions/xtract_odd_even_ratio\";\nimport {xtract_noisiness} from \"../functions/xtract_noisiness\";\n\nexport class HarmonicSpectrumData extends PeakSpectrumData {\n    odd_even_ratio () {\n        if (this.result.odd_even_ratio === undefined) {\n            if (this.f0 === undefined) {\n                this.spectral_fundamental(this.data, this.sampleRate);\n            }\n            this.result.odd_even_ratio = xtract_odd_even_ratio(this.data, this.f0);\n        }\n        return this.result.odd_even_ratio;\n    }\n\n    noisiness() {\n        if (parent.constructor !== PeakSpectrumData) {\n            this.result.noisiness = null;\n        } else {\n            this.result.noisiness = xtract_noisiness(this.nonzero_count(), parent.nonzero_count());\n        }\n        return this.result.noisiness;\n    }\n}\n\nHarmonicSpectrumData.prototype.features = PeakSpectrumData.prototype.features.concat([\n    {\n        name: \"Odd Even Ration\",\n        function: \"odd_even_ratio\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    },\n    {\n        name: \"Noisiness\",\n        function: \"noisiness\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }\n]);\n","/// <reference path=\"../../typings/objects/PeakSpectrumData.d.ts\" />\nimport {SpectrumData} from \"./SpectrumData\";\nimport {HarmonicSpectrumData} from \"./HarmonicSpectrumData\";\nimport {xtract_spectral_inharmonicity} from \"../functions/xtract_spectral_inharmonicity\";\nimport {xtract_harmonic_spectrum} from \"../functions/xtract_harmonic_spectrum\";\n\n\nexport class PeakSpectrumData extends SpectrumData {\n    spectral_inharmonicity() {\n        if (this.result.spectral_inharmonicity === undefined) {\n            this.result.spectral_inharmonicity = xtract_spectral_inharmonicity(this.data, this.sampleRate);\n        }\n        return this.result.spectral_inharmonicity;\n    }\n\n    harmonic_spectrum(threshold) {\n        if (this.result.harmonic_spectrum === undefined) {\n            if (this.f0 === undefined) {\n                this.spectral_fundamental(this.data, this.sampleRate);\n            }\n            this.result.harmonic_spectrum = new HarmonicSpectrumData(this.length, this.sampleRate, this);\n            var hs = xtract_harmonic_spectrum(this.data, this.f0, threshold);\n            this.result.harmonic_spectrum.copyDataFrom(hs.subarray(0, this.length));\n        }\n        return this.result.harmonic_spectrum;\n    }\n}\n\nPeakSpectrumData.prototype.features = SpectrumData.prototype.features.concat([\n    {\n        name: \"Spectral Inharmonicity\",\n        function: \"spectral_inharmonicity\",\n        sub_features: [\"f0\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Harmonic Spectrum\",\n        function: \"harmonic_spectrum\",\n        sub_features: [],\n        parameters: [{\n            name: \"Threshold\",\n            unit: \"\",\n            type: \"number\",\n            minimum: 0,\n            maximum: 100,\n            default: 30\n    }],\n        returns: \"HarmonicSpectrumData\"\n}]);\n","/// <reference path=\"../../typings/objects/SpectrumData.d.ts\" />\nimport {DataPrototype} from \"./DataPrototype\";\nimport {PeakSpectrumData} from \"./PeakSpectrumData\";\nimport {xtract_init_bark} from \"../functions/xtract_init_bark\";\nimport {xtract_array_min} from \"../functions/xtract_array_min\";\nimport {xtract_array_max} from \"../functions/xtract_array_max\";\nimport {xtract_array_sum} from \"../functions/xtract_array_sum\";\nimport {xtract_spectral_centroid} from \"../functions/xtract_spectral_centroid\";\nimport {xtract_spectral_mean} from \"../functions/xtract_spectral_mean\";\nimport {xtract_spectral_variance} from \"../functions/xtract_spectral_variance\";\nimport {xtract_spectral_spread} from \"../functions/xtract_spectral_spread\";\nimport {xtract_spectral_standard_deviation} from \"../functions/xtract_spectral_standard_deviation\";\nimport {xtract_spectral_skewness} from \"../functions/xtract_spectral_skewness\";\nimport {xtract_spectral_kurtosis} from \"../functions/xtract_spectral_kurtosis\";\nimport {xtract_irregularity_k} from \"../functions/xtract_irregularity_k\";\nimport {xtract_irregularity_j} from \"../functions/xtract_irregularity_j\";\nimport {xtract_tristimulus_1, xtract_tristimulus_2, xtract_tristimulus_3} from \"../functions/xtract_tristimulus\";\nimport {xtract_smoothness} from \"../functions/xtract_smoothness\";\nimport {xtract_rolloff} from \"../functions/xtract_rolloff\";\nimport {xtract_loudness} from \"../functions/xtract_loudness\";\nimport {xtract_sharpness} from \"../functions/xtract_sharpness\";\nimport {xtract_flatness} from \"../functions/xtract_flatness\";\nimport {xtract_flatness_db} from \"../functions/xtract_flatness_db\";\nimport {xtract_tonality} from \"../functions/xtract_tonality\";\nimport {xtract_crest} from \"../functions/xtract_crest\";\nimport {xtract_spectral_slope} from \"../functions/xtract_spectral_slope\";\nimport {xtract_spectral_fundamental} from \"../functions/xtract_spectral_fundamental\";\nimport {xtract_nonzero_count} from \"../functions/xtract_nonzero_count\";\nimport {xtract_hps} from \"../functions/xtract_hps\";\nimport {xtract_mfcc} from \"../functions/xtract_mfcc\";\nimport {xtract_dct_2} from \"../functions/xtract_dct_2\";\nimport {xtract_bark_coefficients} from \"../functions/xtract_bark_coefficients\";\nimport {xtract_chroma} from \"../functions/xtract_chroma\";\nimport {xtract_peak_spectrum} from \"../functions/xtract_peak_spectrum\";\n\nexport class SpectrumData extends DataPrototype {\n    constructor(N, sampleRate, parent) {\n        if (N === undefined || N <= 0) {\n            throw (\"SpectrumData constructor requires N to be a defined, whole number\");\n        }\n        if (sampleRate === undefined) {\n            sampleRate = Math.PI;\n        }\n        super(2*N, sampleRate);\n        this._amps = this.data.subarray(0, N);\n        this._freqs = this.data.subarray(N, 2 * N);\n        this._length = N;\n        this._f0 = undefined;\n        this._mfcc = undefined;\n        this._bark = undefined;\n        this._dct = undefined;\n        this._chroma = undefined;\n\n        this.computeFrequencies();\n    }\n    computeFrequencies () {\n        for (let i = 0; i < this._length; i++) {\n            this._freqs[i] = (i / this._length) * (this.sampleRate / 2);\n        }\n    }\n    get sampleRate() {\n        return this._sampleRate;\n    }\n    set sampleRate(fs) {\n        if (this._sampleRate === Math.PI) {\n            this._sampleRate = fs;\n            this.computeFrequencies();\n            if (this._bark !== undefined) {\n                this._bark = xtract_init_bark(this._length, this._sampleRate );\n            }\n\n        } else {\n            throw (\"Cannot set one-time variable\");\n        }\n    }\n\n    get f0() {\n        return this._f0;\n    }\n\n    set f0(f0) {\n        if (typeof f0 === \"number\") {\n            this._f0 = f0;\n        }\n    }\n\n    get length() {\n        return this._length;\n    }\n\n    init_mfcc(num_bands, freq_min, freq_max, style) {\n        this._mfcc = this.createMfccCoefficients(this._length, this.sampleRate * 0.5, style, freq_min, freq_max, num_bands);\n        this.result.mfcc = undefined;\n        return this._mfcc;\n    }\n\n    init_bark(numBands) {\n        if (typeof numBands !== \"number\" || numBands < 0 || numBands > 26) {\n            numBands = 26;\n        }\n        this._bark = this.createBarkCoefficients(this._length, this._Fs, numBands);\n        return this._bark;\n    }\n\n    init_chroma(nbins, A440, f_ctr, octwidth) {\n        if (typeof nbins !== \"number\" || nbins <= 1) {\n            nbins = 12;\n        }\n        if (typeof A440 !== \"number\" || A440 <= 27.5) {\n               A440 = 440;\n        }\n        if (typeof f_ctr !== \"number\") {\n               f_ctr = 1000;\n        }\n        if (typeof octwidth !== \"number\") {\n               octwidth = 1;\n        }\n        this._chroma = this.createChromaCoefficients(this._length, this._Fs, nbins, A440, f_ctr, octwidth);\n        this.result.chroma = undefined;\n        return this._chroma;\n    }\n\n    minimum() {\n        if (this.result.minimum === undefined) {\n            this.result.minimum = xtract_array_min(this._amps);\n        }\n        return this.result.minimum;\n    }\n\n    maximum() {\n        if (this.result.maximum === undefined) {\n            this.result.maximum = xtract_array_max(this._amps);\n        }\n        return this.result.maximum;\n    }\n\n    sum() {\n        if (this.result.sum === undefined) {\n            this.result.sum = xtract_array_sum(this._amps);\n        }\n        return this.result.sum;\n    }\n\n    spectral_centroid() {\n        if (this.result.spectral_centroid === undefined) {\n            this.result.spectral_centroid = xtract_spectral_centroid(this.data);\n        }\n        return this.result.spectral_centroid;\n    }\n\n    spectral_mean () {\n        if (this.result.spectral_mean === undefined) {\n            this.result.spectral_mean = xtract_spectral_mean(this.data);\n        }\n        return this.result.spectral_mean;\n    }\n\n    spectral_variance () {\n        if (this.result.spectral_variance === undefined) {\n            this.result.spectral_variance = xtract_spectral_variance(this.data, this.spectral_centroid());\n        }\n        return this.result.spectral_variance;\n    }\n\n    spectral_spread() {\n        if (this.result.spectral_spread === undefined) {\n            this.result.spectral_spread = xtract_spectral_spread(this.data, this.spectral_centroid());\n        }\n        return this.result.spectral_spread;\n    }\n\n    spectral_standard_deviation() {\n        if (this.result.spectral_standard_deviation === undefined) {\n            this.result.spectral_standard_deviation = xtract_spectral_standard_deviation(this.data, this.spectral_variance());\n        }\n        return this.result.spectral_standard_deviation;\n    }\n\n    spectral_skewness() {\n        if (this.result.spectral_skewness === undefined) {\n            this.result.spectral_skewness = xtract_spectral_skewness(this.data, this.spectral_centroid(), this.spectral_standard_deviation());\n        }\n        return this.result.spectral_skewness;\n    }\n\n    spectral_kurtosis() {\n        if (this.result.spectral_kurtosis === undefined) {\n            this.result.spectral_kurtosis = xtract_spectral_kurtosis(this.data, this.spectral_centroid(), this.spectral_standard_deviation());\n        }\n        return this.result.spectral_kurtosis;\n    }\n\n    irregularity_k () {\n        if (this.result.irregularity_k === undefined) {\n            this.result.irregularity_k = xtract_irregularity_k(this.data);\n        }\n        return this.result.irregularity_k;\n    }\n\n    irregularity_j () {\n        if (this.result.irregularity_j === undefined) {\n            this.result.irregularity_j = xtract_irregularity_j(this.data);\n        }\n        return this.result.irregularity_j;\n    }\n\n    tristimulus_1 () {\n        if (this._f0 === undefined) {\n            this.spectral_fundamental();\n        }\n        if (this.result.tristimulus_1 === undefined) {\n            this.result.tristimulus_1 = xtract_tristimulus_1(this.data, this._f0);\n        }\n        return this.result.tristimulus_1;\n    }\n    tristimulus_2 () {\n        if (this._f0 === undefined) {\n            this.spectral_fundamental();\n        }\n        if (this.result.tristimulus_2 === undefined) {\n            this.result.tristimulus_2 = xtract_tristimulus_2(this.data, this._f0);\n        }\n        return this.result.tristimulus_2;\n    }\n    tristimulus_3 () {\n        if (this._f0 === undefined) {\n            this.spectral_fundamental();\n        }\n        if (this.result.tristimulus_3 === undefined) {\n            this.result.tristimulus_3 = xtract_tristimulus_3(this.data, this._f0);\n        }\n        return this.result.tristimulus_3;\n    }\n\n    smoothness() {\n        if (this.result.smoothness === undefined) {\n            this.result.smoothness = xtract_smoothness(this.data);\n        }\n        return this.result.smoothness;\n    }\n\n    rolloff(threshold) {\n        if (this.result.rolloff === undefined) {\n            this.result.rolloff = xtract_rolloff(this.data, this.sampleRate, threshold);\n        }\n        return this.result.rolloff;\n    }\n\n    loudness() {\n        if (this.result.loudness === undefined) {\n            this.result.loudness = xtract_loudness(this.bark_coefficients());\n        }\n        return this.result.loudness;\n    }\n\n    sharpness () {\n        if (this.result.sharpness === undefined) {\n            this.result.sharpness = xtract_sharpness(this.bark_coefficients());\n        }\n        return this.result.sharpness;\n    }\n\n    flatness () {\n        if (this.result.flatness === undefined) {\n            this.result.flatness = xtract_flatness(this.data);\n        }\n        return this.result.flatness;\n    }\n\n    flatness_db () {\n        if (this.result.flatness_db === undefined) {\n            this.result.flatness_db = xtract_flatness_db(this.data, this.flatness());\n        }\n        return this.result.flatness_db;\n    }\n\n    tonality() {\n        if (this.result.tonality === undefined) {\n            this.result.tonality = xtract_tonality(this.data, this.flatness_db());\n        }\n        return this.result.tonality;\n    }\n\n    spectral_crest_factor () {\n        if (this.result.spectral_crest_factor === undefined) {\n            this.result.spectral_crest_factor = xtract_crest(this._amps, this.maximum(), this.spectral_mean());\n        }\n        return this.result.spectral_crest_factor;\n    }\n\n    spectral_slope() {\n        if (this.result.spectral_slope === undefined) {\n            this.result.spectral_slope = xtract_spectral_slope(this.data);\n        }\n        return this.result.spectral_slope;\n    }\n\n    spectral_fundamental() {\n        if (this.result.spectral_fundamental === undefined) {\n            this.result.spectral_fundamental = xtract_spectral_fundamental(this.data, _Fs);\n            this.f0 = this.result.spectral_fundamental;\n        }\n        return this.result.spectral_fundamental;\n    }\n\n    nonzero_count () {\n        if (this.result.nonzero_count === undefined) {\n            this.result.nonzero_count = xtract_nonzero_count(_amps);\n        }\n        return this.result.nonzero_count;\n    }\n\n    hps () {\n        if (this.result.hps === undefined) {\n            this.result.hps = xtract_hps(this.data);\n        }\n        return this.result.hps;\n    }\n\n    mfcc(num_bands, freq_min, freq_max) {\n        if (this._mfcc === undefined) {\n            if (freq_min === undefined) {\n                throw (\"Run init_mfcc(num_bands, freq_min, freq_max, style) first\");\n            } else {\n                this._mfcc = this.init_mfcc(num_bands, freq_min, freq_max);\n            }\n        }\n        if (this.result.mfcc === undefined) {\n            this.result.mfcc = xtract_mfcc(this.data, this._mfcc);\n        }\n        return this.result.mfcc;\n    }\n\n    dct () {\n        if (this._dct === undefined) {\n            this._dct = this.createDctCoefficients(this._length);\n        }\n        if (this.result.dct === undefined) {\n            this.result.dct = xtract_dct_2(this._amps,this._dct);\n        }\n        return this.result.dct;\n    }\n\n    bark_coefficients(num_bands) {\n        if (this.result.bark_coefficients === undefined) {\n            if (this._bark === undefined) {\n                this._bark = this.init_bark(num_bands);\n            }\n            this.result.bark_coefficients = xtract_bark_coefficients(this.data, this._bark);\n        }\n        return this.result.bark_coefficients;\n    }\n\n    chroma(nbins, A440, f_ctr, octwidth) {\n        if(this.result.chroma === undefined) {\n            if (this._chroma === undefined) {\n                this._chroma = this.init_chroma(nbins, A440, f_ctr, octwidth);\n            }\n            this.result.chroma = xtract_chroma(this.data, this._chroma);\n        }\n        return this.result.chroma;\n    }\n\n    peak_spectrum(threshold) {\n        if (this.result.peak_spectrum === undefined) {\n            this.result.peak_spectrum = new PeakSpectrumData(this._length, this.sampleRate, this);\n            var ps = xtract_peak_spectrum(this.data, this.sampleRate / this._length, threshold);\n            this.result.peak_spectrum.copyDataFrom(ps.subarray(0, this._length));\n        }\n        return this.result.peak_spectrum;\n    }\n}\n\nSpectrumData.prototype.features = [\n    {\n        name: \"Minimum\",\n        function: \"minimum\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Maximum\",\n        function: \"maximum\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Sum\",\n        function: \"sum\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Centroid\",\n        function: \"spectral_centroid\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Mean\",\n        function: \"spectral_mean\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Variance\",\n        function: \"spectral_variance\",\n        sub_features: [\"spectral_mean\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Spread\",\n        function: \"spectral_spread\",\n        sub_features: [\"spectral_centroid\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Standard Deviation\",\n        function: \"spectral_standard_deviation\",\n        sub_features: [\"spectral_variance\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Skewness\",\n        function: \"spectral_skewness\",\n        sub_features: [\"spectral_mean\", \"spectral_standard_deviation\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Kurtosis\",\n        function: \"spectral_kurtosis\",\n        sub_features: [\"spectral_mean\", \"spectral_standard_deviation\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Irregularity K\",\n        function: \"irregularity_k\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Irregularity J\",\n        function: \"irregularity_j\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Tristimulus 1\",\n        function: \"tristimulus_1\",\n        sub_features: [\"spectral_fundamental\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Tristimulus 2\",\n        function: \"tristimulus_2\",\n        sub_features: [\"spectral_fundamental\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Tristimulus 3\",\n        function: \"tristimulus_3\",\n        sub_features: [\"spectral_fundamental\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Smoothness\",\n        function: \"smoothness\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Rolloff\",\n        function: \"rolloff\",\n        sub_features: [],\n        parameters: [{\n            name: \"Threshold\",\n            unit: \"%\",\n            type: \"number\",\n            minimum: 0,\n            maximum: 100,\n            default: 90\n    }],\n        returns: \"number\"\n}, {\n        name: \"Loudness\",\n        function: \"loudness\",\n        sub_features: [\"bark_coefficients\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Sharpness\",\n        function: \"sharpness\",\n        sub_features: [\"bark_coefficients\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Flatness\",\n        function: \"flatness\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Flatness DB\",\n        function: \"flatness_db\",\n        sub_features: [\"flatness\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Tonality\",\n        function: \"tonality\",\n        sub_features: [\"flatness_db\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Crest Factor\",\n        function: \"spectral_crest_factor\",\n        sub_features: [\"maximum\", \"spectral_mean\"],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Spectral Slope\",\n        function: \"spectral_slope\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Fundamental Frequency\",\n        function: \"spectral_fundamental\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"Non-Zero count\",\n        function: \"nonzero_count\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"HPS\",\n        function: \"hps\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n}, {\n        name: \"MFCC\",\n        function: \"mfcc\",\n        sub_features: [],\n        parameters: [{\n            name: \"Band Count\",\n            unit: \"\",\n            type: \"number\",\n            minimum: 0,\n            maximum: undefined,\n            default: 26\n    }, {\n            name: \"Minimum Frequency\",\n            unit: \"Hz\",\n            type: \"number\",\n            minimum: 0,\n            maximum: undefined,\n            default: 400\n    }, {\n            name: \"Maximum Frequency\",\n            unit: \"Hz\",\n            minimum: 0,\n            maximum: undefined,\n            default: 20000\n    }],\n        returns: \"array\"\n}, {\n        name: \"Chroma\",\n        function: \"chroma\",\n        sub_features: [],\n        parameters: [{\n            name: \"nbins\",\n            unit: \"\",\n            type: \"number\",\n            minimum: 2,\n            maximum: undefined,\n            default: 12\n    }, {\n            name: \"A440\",\n            unit: \"\",\n            type: \"number\",\n            minimum: 220,\n            maximum: 880,\n            default: 440\n    }, {\n            name: \"f_ctr\",\n            unit: \"\",\n            type: \"number\",\n            minimum: undefined,\n            maximum: undefined,\n            default: 1000\n    }, {\n            name: \"octwidth\",\n            unit: \"\",\n            type: \"number\",\n            minimum: undefined,\n            maximum: undefined,\n            default: 1\n    }],\n        returns: \"array\"\n}, {\n        name: \"DCT\",\n        function: \"dct\",\n        sub_features: [],\n        parameters: [],\n        returns: \"array\"\n}, {\n        name: \"Bark Coefficients\",\n        function: \"bark_coefficients\",\n        sub_features: [],\n        parameters: [{\n            name: \"Band Count\",\n            unit: \"\",\n            type: \"number\",\n            minimum: 0,\n            maximum: 26,\n            default: 26\n    }],\n        returns: \"array\"\n}, {\n        name: \"Peak Spectrum\",\n        function: \"peak_spectrum\",\n        sub_features: [],\n        parameters: [{\n            name: \"Threshold\",\n            unit: \"\",\n            type: \"number\",\n            minimum: 0,\n            maximum: 100,\n            default: 30\n    }],\n        returns: \"PeakSpectrumData\"\n}];\n","/// <reference path=\"../../typings/objects/TimeData.d.ts\" />\nimport {DataPrototype} from \"./DataPrototype\";\nimport {SpectrumData} from \"./SpectrumData\";\nimport {xtract_init_wavelet} from \"../functions/xtract_init_wavelet\";\nimport {xtract_array_min} from \"../functions/xtract_array_min\";\nimport {xtract_array_max} from \"../functions/xtract_array_max\";\nimport {xtract_array_sum} from \"../functions/xtract_array_sum\";\nimport {xtract_mean} from \"../functions/xtract_mean\";\nimport {xtract_temporal_centroid} from \"../functions/xtract_temporal_centroid\";\nimport {xtract_variance} from \"../functions/xtract_variance\";\nimport {xtract_standard_deviation} from \"../functions/xtract_standard_deviation\";\nimport {xtract_average_deviation} from \"../functions/xtract_average_deviation\";\nimport {xtract_skewness} from \"../functions/xtract_skewness\";\nimport {xtract_kurtosis} from \"../functions/xtract_kurtosis\";\nimport {xtract_zcr} from \"../functions/xtract_zcr\";\nimport {xtract_crest} from \"../functions/xtract_crest\";\nimport {xtract_rms_amplitude} from \"../functions/xtract_rms_amplitude\";\nimport {xtract_lowest_value} from \"../functions/xtract_lowest_value\";\nimport {xtract_nonzero_count} from \"../functions/xtract_nonzero_count\";\nimport {xtract_wavelet_f0} from \"../functions/xtract_wavelet_f0\";\nimport {xtract_energy} from \"../functions/xtract_energy\";\nimport {xtract_spectrum} from \"../functions/xtract_spectrum\";\nimport {xtract_dct_2} from \"../functions/xtract_dct_2\";\nimport {xtract_autocorrelation} from \"../functions/xtract_autocorrelation\";\nimport {xtract_amdf} from \"../functions/xtract_amdf\";\nimport {xtract_asdf} from \"../functions/xtract_asdf\";\nimport {xtract_yin} from \"../functions/xtract_yin\";\nimport {xtract_onset} from \"../functions/xtract_onset\";\nimport {xtract_resample} from \"../functions/xtract_resample\";\n\nexport class TimeData extends DataPrototype {\n    constructor(input, sampleRate) {\n        if (sampleRate <= 0) {\n            sampleRate = undefined;\n            console.log(\"Invalid parameter for 'sampleRate' for TimeData\");\n        }\n\n        if (typeof input === \"object\") {\n            var src, src_data;\n            if (input instanceof TimeData) {\n                src = src.getData();\n                super(src.length, sampleRate);\n                this.copyDataFrom(src, src.length, 0);\n            } else if (input instanceof Float32Array || input instanceof Float64Array) {\n                src = input;\n                super(src.length, sampleRate);\n                this.copyDataFrom(src, src.length, 0);\n            } else {\n                throw (\"TimeData: Invalid object passed as first argument.\");\n            }\n\n        } else if (typeof input === \"number\") {\n            if (input <= 0 || input !== Math.floor(input)) {\n                throw (\"TimeData: Invalid number passed as first argument.\");\n            }\n            super(input, sampleRate);\n        } else {\n            throw (\"TimeData: Constructor has invalid operators!\");\n        }\n\n        this._dct = undefined;\n        this._wavelet = xtract_init_wavelet();\n    }\n    getFrames(frameSize, hopSize) {\n        if (typeof frameSize !== \"number\" || frameSize <= 0 || frameSize !== Math.floor(frameSize)) {\n            throw (\"frameSize must be a defined, positive integer\");\n        }\n        if (typeof hopSize !== \"number\") {\n            hopSize = frameSize;\n        }\n        var num_frames = Math.ceil(this.data.length / frameSize);\n        var result_frames = [];\n        for (var i = 0; i < num_frames; i++) {\n            var frame = new TimeData(hopSize, this.sampleRate);\n            frame.copyDataFrom(this.data.subarray(frameSize * i, frameSize * i + hopSize));\n            result_frames.push(frame);\n        }\n        return result_frames;\n    }\n\n    // Features\n    minimum() {\n        if (this.result.minimum === undefined) {\n            this.result.minimum = xtract_array_min(this.data);\n        }\n        return this.result.minimum;\n    }\n\n    maximum() {\n        if (this.result.maximum === undefined) {\n            this.result.maximum = xtract_array_max(this.data);\n        }\n        return this.result.maximum;\n    }\n\n    sum() {\n        if (this.result.sum === undefined) {\n            this.result.sum = xtract_array_sum(this.data);\n        }\n        return this.result.sum;\n    }\n\n    mean() {\n        if (this.result.mean === undefined) {\n            this.result.mean = xtract_mean(this.data);\n        }\n        return this.result.mean;\n    }\n\n    temporal_centroid(window_ms) {\n        if (this.result.temporal_centroid === undefined) {\n            this.energy(window_ms);\n            this.result.temporal_centroid = xtract_temporal_centroid(this.result.energy.data, this.sampleRate, window_ms);\n        }\n        return this.result.temporal_centroid;\n    }\n\n    variance() {\n        if (this.result.variance === undefined) {\n            this.result.variance = xtract_variance(this.data, this.mean());\n        }\n        return this.result.variance;\n    }\n\n    standard_deviation() {\n        if (this.result.standard_deviation === undefined) {\n            this.result.standard_deviation = xtract_standard_deviation(this.data, this.variance());\n        }\n        return this.result.standard_deviation;\n    }\n\n    average_deviation () {\n        if (this.result.average_deviation === undefined) {\n            this.result.average_deviation = xtract_average_deviation(this.data, this.mean());\n        }\n        return this.result.average_deviation;\n    }\n\n    skewness () {\n        if (this.result.skewness === undefined) {\n            this.result.skewness = xtract_skewness(this.data, this.mean(), this.standard_deviation());\n        }\n        return this.result.skewness;\n    }\n\n    kurtosis () {\n        if (this.result.kurtosis === undefined) {\n            this.result.kurtosis = xtract_kurtosis(this.data, this.mean(), this.standard_deviation());\n        }\n        return this.result.kurtosis;\n    }\n\n    zcr  () {\n        if (this.result.zcr === undefined) {\n            this.result.zcr = xtract_zcr(this.data);\n        }\n        return this.result.zcr;\n    }\n\n    crest_factor () {\n        if (this.result.crest_factor === undefined) {\n            this.result.crest_factor = xtract_crest(this.data, this.maximum(), this.mean());\n        }\n        return this.result.crest_factor;\n    }\n\n    rms_amplitude () {\n        if (this.result.rms_amplitude === undefined) {\n            this.result.rms_amplitude = xtract_rms_amplitude(this.data);\n        }\n        return this.result.rms_amplitude;\n    }\n\n    lowest_value (threshold) {\n        if (this.result.lowest_value === undefined) {\n            this.result.lowest_value = xtract_lowest_value(this.data, threshold);\n        }\n        return this.result.lowest_value;\n    }\n\n    highest_value () {\n        if (this.result.nonzero_count === undefined) {\n            this.result.nonzero_count = xtract_nonzero_count(this.data);\n        }\n        return this.result.nonzero_count;\n    }\n\n    f0 () {\n        if (this._wavelet === undefined) {\n            this._wavelet = this.init_wavelet();\n        }\n        if (this.result.f0 === undefined) {\n            this.result.f0 = xtract_wavelet_f0(this.data, this.sampleRate, this._wavelet);\n        }\n        return this.result.f0;\n    }\n\n    energy (window_ms) {\n        if (this.result.energy === undefined || this.result.energy.window_ms !== window_ms) {\n            this.result.energy = {\n                'data': xtract_energy(this.data, this.sampleRate, window_ms),\n                'window_ms': window_ms\n            };\n        }\n        return this.result.energy;\n    }\n\n    spectrum() {\n        if (this.result.spectrum === undefined) {\n            var _spec = xtract_spectrum(this.data, this.sampleRate, true, false);\n            this.result.spectrum = new SpectrumData(_spec.length / 2, this.sampleRate);\n            this.result.spectrum.copyDataFrom(_spec);\n            return this.result.spectrum;\n        }\n    }\n\n    dct() {\n        if (this._dct === undefined) {\n            this._dct = this.createDctCoefficients(this.data.length);\n        }\n        if (this.result.dct === undefined) {\n            this.result.dct = xtract_dct_2(this.data, this._dct);\n        }\n        return this.result.dct;\n    }\n\n    autocorrelation () {\n        if (this.result.autocorrelation === undefined) {\n            this.result.autocorrelation = xtract_autocorrelation(this.data);\n        }\n        return this.result.autocorrelation;\n    }\n\n    amdf () {\n        if (this.result.amdf === undefined) {\n            this.result.amdf = xtract_amdf(this.data);\n        }\n        return this.result.amdf;\n    }\n\n    asdf () {\n        if (this.result.asdf === undefined) {\n            this.result.asdf = xtract_asdf(this.data);\n        }\n        return this.result.asdf;\n    }\n\n    yin() {\n        if (this.result.yin === undefined) {\n            this.result.yin = xtract_yin(this.data);\n        }\n        return this.result.yin;\n    }\n\n    onset(frameSize) {\n        if (this.result.onset === undefined || this.result.onset.frameSize !== frameSize) {\n            this.result.onset = {\n                'data': xtract_onset(this.data, frameSize),\n                'frameSize': frameSize\n            };\n        }\n        return this.result.onset;\n    }\n\n    resample(targetSampleRate) {\n        if (this.sampleRate === undefined) {\n            throw (\"Source sampleRate must be defined\");\n        }\n        if (typeof targetSampleRate !== \"number\" || targetSampleRate <= 0) {\n            throw (\"Target sampleRate must be a positive number\");\n        }\n        var resampled = xtract_resample(this.data, targetSampleRate, this.sampleRate);\n        var reply = new TimeData(resampled.length, targetSampleRate);\n        reply.copyDataFrom(resampled);\n        this.result.resample = reply;\n        return reply;\n    }\n}\n\nTimeData.prototype.features = [\n    {\n        name: \"Minimum\",\n        function: \"minimum\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Maximum\",\n        function: \"maximum\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Sum\",\n        function: \"sum\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Mean\",\n        function: \"mean\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Temporal Centroid\",\n        function: \"temporal_centroid\",\n        sub_features: [\"energy\"],\n        parameters: [{\n            name: \"Window Time\",\n            unit: \"ms\",\n            type: \"number\",\n            minimum: 1,\n            maximum: undefined,\n            default: 100\n        }],\n        returns: \"number\"\n    }, {\n        name: \"Variance\",\n        function: \"variance\",\n        sub_features: [\"mean\"],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Standard Deviation\",\n        function: \"standard_deviation\",\n        sub_features: [\"variance\"],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Average Deviation\",\n        function: \"average_deviation\",\n        sub_features: [\"mean\"],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Skewness\",\n        function: \"skewness\",\n        sub_features: [\"mean\", \"standard_deviation\"],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Kurtosis\",\n        function: \"kurtosis\",\n        sub_features: [\"mean\", \"standard_deviation\"],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Zero Crossing Rate\",\n        function: \"zcr\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Crest Factor\",\n        function: \"crest_factor\",\n        sub_features: [\"maximum\", \"mean\"],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"RMS Amplitude\",\n        function: \"rms_amplitude\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Lowest Value\",\n        function: \"lowest_value\",\n        sub_features: [],\n        parameters: [{\n            name: \"Threshold\",\n            unit: \"\",\n            type: \"number\",\n            minimum: undefined,\n            maximum: undefined,\n            default: undefined\n        }],\n        returns: \"number\"\n    }, {\n        name: \"Highest Value\",\n        function: \"highest_value\",\n        sub_features: [],\n        parameters: [{\n            name: \"Threshold\",\n            unit: \"\",\n            type: \"number\",\n            minimum: undefined,\n            maximum: undefined,\n            default: undefined\n        }],\n        returns: \"number\"\n    }, {\n        name: \"Non-Zero Count\",\n        function: \"nonzero_count\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Fundamental Frequency\",\n        function: \"f0\",\n        sub_features: [],\n        parameters: [],\n        returns: \"number\"\n    }, {\n        name: \"Energy\",\n        function: \"energy\",\n        sub_features: [],\n        parameters: [{\n            name: \"Window\",\n            unit: \"ms\",\n            type: \"number\",\n            minimum: 1,\n            maximum: undefined,\n            default: 100\n        }],\n        returns: \"object\"\n    }, {\n        name: \"Spectrum\",\n        function: \"spectrum\",\n        sub_features: [],\n        parameters: [],\n        returns: \"SpectrumData\"\n    }, {\n        name: \"DCT\",\n        function: \"dct\",\n        sub_features: [],\n        parameters: [],\n        returns: \"array\"\n    }, {\n        name: \"Autocorrelation\",\n        function: \"autocorrelation\",\n        sub_features: [],\n        parameters: [],\n        returns: \"array\"\n    }, {\n        name: \"AMDF\",\n        function: \"amdf\",\n        sub_features: [],\n        parameters: [],\n        returns: \"array\"\n    }, {\n        name: \"ASDF\",\n        function: \"asdf\",\n        sub_features: [],\n        parameters: [],\n        returns: \"array\"\n    }, {\n        name: \"YIN Pitch\",\n        function: \"yin\",\n        sub_features: [],\n        parameters: [],\n        returns: \"array\"\n    }, {\n        name: \"Onset Detection\",\n        function: \"onset\",\n        sub_features: [],\n        parameters: [{\n            name: \"Frame Size\",\n            unit: \"samples\",\n            type: \"number\",\n            minimum: 1,\n            maximum: undefined,\n            default: 1024\n        }],\n        returns: \"array\"\n    }, {\n        name: \"Resample\",\n        function: \"resample\",\n        sub_features: [],\n        parameters: [{\n            name: \"Target Sample Rate\",\n            unit: \"Hz\",\n            type: \"number\",\n            minimum: 0,\n            maximum: undefined,\n            default: 8000\n        }],\n        returns: \"TimeData\"\n    }];\n"],"sourceRoot":""}